<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="UJava应用程序和数据库的整合面向对象语言能够用丰富的方式对真实的世界进行建模。。关系数据库将数据持久化在表格中，而表格通常是一种更平坦的数据结构，对同样的表达能力具有局限性。
本章讨论如何连接和使用数据库，以及如何将Java数据类型持久化到数据库中。本章所有示例都使用MySQL数据库，包括通过M">
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="wsh549"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="wsh549"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>wsh549</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="wsh549" type="application/atom+xml">
</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2020/11/15/Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B4%E5%90%88/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-11-15</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h1 id="UJava应用程序和数据库的整合"><a href="#UJava应用程序和数据库的整合" class="headerlink" title="UJava应用程序和数据库的整合"></a>UJava应用程序和数据库的整合</h1><p>面向对象语言能够用丰富的方式对真实的世界进行建模。。关系数据库将数据持久化在表格中，而表格通常是一种更平坦的数据结构，对同样的表达能力具有局限性。</p>
<p>本章讨论如何连接和使用数据库，以及如何将Java数据类型持久化到数据库中。本章所有示例都使用MySQL数据库，包括通过MySQL控制台访问(用mysql&gt;提示符表示)，以及通过Java的数据库接口访问。</p>
<h2 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h2><p>SQL是一种抽象的声明式语言，用于在关系数据库中执行查询和数据操作。SQL是一种标准，和具体的数据库实现无关。如今基本上所有正在使用的成熟的关系数据库产品都支持SQL。</p>
<p><strong><u><em>如何通过SQL从关系数据库检索数据？</em></u></strong></p>
<p>关系数据库中的数据保存在很多表中，而表是由行和列组成的。每一个表通常都描述了一个逻辑的实体（entity）,也可以称为关系(relation), 例如一个人，一个地址或一个库存清单项。数据库中的每一行称为一条记录(record)， 每一条记录都可以被唯一地标识。唯一标识符称为主键(primary key). </p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115145904.png" alt="image-20201115145855605"></p>
<p>从表中可以看出，每一条记录都可以通过employee_number列标识。这个表只保存了和员工相关的信息。</p>
<p>SQL是一种用于解释和操作关系数据库数据的灵活语言，提供了一种对问题域有意义的表达式形式。如果要查询某张表，应该使用SQL SELECT语句：</p>
<p><code>SELECT name,office_location_id FROM emplyees;</code></p>
<p>这条查询语句返回的是employees表中的所有行，但是只包含name和 office_location_id列：</p>
<p><code>mysql&gt; SELECT name,office_location_id FROM emplyees;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115150855.png" alt="image-20201115150828278"></p>
<blockquote>
<p>SQL语句和大小写敏感性</p>
<p>通常来说，SQL语句是大小写敏感的。大小写敏感的不仅包括语句的关键字(例如SELECT, FROM 和WHERE等)，还包括查询语句中的对象， 例如列表和表名等。</p>
<p>一个常用的约定是SQL关键字用大写，对象名称用小写。这种约定可以帮助代码的读者根据大小写变化将查询语句分解为不同的逻辑块。</p>
</blockquote>
<p>有时候需要检索某一指定的行或某一些特定的行。为此，需要在SELECT语句中加上WHERE 子句。这个子句会对一个布尔表达式求值而且会针对每一行进行求值。如果表达式对某一行求值为真，那么这一行就会被包含在结果集中：</p>
<p><code>mysql&gt; SELECT name,office_location_id FROM emplyees WHERE employee_number&gt;2;</code><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115153627.png" alt="image-20201115153626879"></p>
<p>注意这个例子中的WHERE子句对并不包含在结果集中的一个列进行求值，也就是说在查询语句中可以访问任意列，即使被访问的列不在最终的结果集中。</p>
<p>如果要在查询中返回所有的列，那么可以使用通配符*表示所有的列：</p>
<p><code>mysql&gt; SELECT * FROM emplyees WHERE employee_number = 1;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115154120.png" alt="image-20201115154120113"></p>
<p>如果在表中添加，删除，或者修改了列，此查询都可以正常工作，只不过返回的结果不同。假设这个表隶属于一个公司的大型数据库，那么可以想象这个数据库中还有其他表示不同实体的表，例如表示公司所有办公地点的信息以及每个人工作地点的信息，甚至还有各个管理层结构的信息。数据库的迷人之处和威力就在于这些关系之间的交互。</p>
<p>下面的表定义了这个公司数据库中的另外一个，名为office_locations 的表。</p>
<p><code> CREATE TABLE office_location (office_location_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,location_name VARCHAR(20),address VARCHAR(20),lease_expiry_date DATE); Query OK, 0 rows affected (2.16 sec)</code></p>
<p><code>mysql&gt; INSERT INTO office_location VALUES(1,&#39;New York&#39;,&#39;Union Plaza&#39;,NULL),(2,&#39;Paris&#39;,&#39;Revolution Place&#39;,NULL),(3,&#39;London&#39;,&#39;Piccadilly Square&#39;,&#39;2014-05-30&#39;); Query OK, 3 rows affected (0.12 sec)</code></p>
<p><code>mysql&gt; SELECT * FROM office_location;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115160107.png" alt="image-20201115160106939"></p>
<p>尽管这个表中的信息从逻辑上和employees表是分离的，但是这两个表之间肯定是有关系的。对这两个表检索可以得到以下结果：</p>
<p><code>mysql&gt; select emplyees.name,office_location.location_name     -&gt; from emplyees,office_location;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115160840.png" alt="image-20201115160840797"></p>
<p>这些数据并不是我们想要的。为什么会得到这样的结果呢？因为数据库并不知道应该怎样将这些行组织在一起，因此只能从employees表中取出每一行，然后将每一行和office_locations 表中的每一行进行配对。如果需要更有意义的结果，必须告诉数据库怎样组织这些表的关系，代码清单如下：</p>
<blockquote>
<p>两个表的连接</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT*</span><br><span class="line">	FROM emplyees</span><br><span class="line">	JOIN office_location</span><br><span class="line">	ON emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115161821.png" alt="image-20201115161820981"></p>
<p>这条语句可以返回我们所需要的数据集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select emplyees.name,office_location.location_name</span><br><span class="line">from emplyees</span><br><span class="line">join office_location</span><br><span class="line">on emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115162232.png" alt="image-20201115162232315"></p>
<p>两个或者多个表查询称为连接(join)。执行连接还可以使用另一种语法，可以在SQL语句的FROM部分列出所有的表，然后再WHERE子句中连接这些表即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM emplyees,office_location</span><br><span class="line">WHERE emplyees.office_location_id &#x3D; office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115162857.png" alt="image-20201115162857038"></p>
<p>尽管两者看上去区别并不大，但是前一种连接查询（称为ANSI join）对于关系的区分更为清晰。如果上述查询中有WHRER子句，那么这个子句中的每一个部分都会用于数据行的过滤，而不会用于定义表之间的关系。</p>
<p>emplyees表的offic_location_id列引用了office_locations表中同名的列。这一列称为外键(forign key),表示引用其他表中列的列。在数据库中设置外键关系是可选的操作，然而这么做可以优化查询功能，因为数据库会知道针对这个列的连接操作和过程操作是预料之中的。</p>
<p>定义外键还可以强制保证引用的完整性：在emplyees表中，office_location_id的取值不可以超出office_locations表中对应的取值范围。反过来，在emplyees表中存在的office_location_id不可以在office_locationa表中删除，每一个员工都必须有合法的办公地点。</p>
<p>如果在定义表时忽略了外键关系，那么两个表之间就没有引用完整性：引用的列中可以包含被连接的表中不存在的数据。不过有时候者正是你所需要的。</p>
<p>==<strong><em>什么时内连接？什么时外连接？</em></strong>==</p>
<p>默认情况下，两个表中满足匹配条件的行都会包含在连接内。此外还可以指定连接操作中的一个或两个表中的所有行都包含在连接中，用NULL填补缺失的匹配。</p>
<p>office_location 表中包含一些在employees表中没有引用的数据行。这肯是因为这家公司目前还有空的办公地点。上面的代码中没有出现这个办公地点。</p>
<p>在查询的JOIN字句中，如果指定的是LEFT OUTER JOIN, 那么结果中会包含来自查询中左侧的所有行，在右侧没有匹配的地方则填上NULL。RIGHT OUTER JOIN则是相反的操作。</p>
<blockquote>
<p>右外连接查询</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">	FROM emplyees</span><br><span class="line">	RIGHT OUTER JOIN office_location</span><br><span class="line">	ON emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115170013.png" alt="image-20201115170003352"></p>
<p>此查询为每一个location_name都返回了一条结果，不论其对应的位置有没有雇员在办公：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT emplyees.name,office_location.location_name</span><br><span class="line">FROM emplyees</span><br><span class="line">RIGHT OUTER JOIN office_location</span><br><span class="line">ON emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115170852.png" alt="image-20201115170852534"></p>
<p>左外连接和右外连接还可以同时进行，在两个表中对于不存在的项都填入NULL，使用的语法是FULL OUTER JOIN。在employees表和office_locations表之间不能执行这种连接，因为office_location_id是一个外键关系：不可能有员工工作在数据库中不存在的地点。</p>
<p><strong><u><em>SQL能对数据库中的数据进行分析吗？</em></u></strong></p>
<p>SQL包含了很多可以对列执行计算的函数。如果你有使用关系式数据库的经验，那么你可能使用过计算表中行数的COUNT函数：</p>
<p><code>SELECT COUNT(*) from enployees;</code></p>
<p>此查询返回的是employees表中行的数目。</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115175516.png" alt="image-20201115175515996"></p>
<p>下表定义了一个员工工资表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table salaries (employee_number int not null primary key auto_increment,annual_salary VARCHAR(20),last_update_date VARCHAR(20));</span><br><span class="line">mysql&gt; INSERT INTO salaries values(1,20000,2013-06-29),(2,12000,2013-06-29),(3,6000,2012-06-10),(4,6000,2013-06-16),(5,12000,2013-05-26);</span><br><span class="line">mysql&gt; select * from salaries;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115191021.png" alt="image-20201115191021437"></p>
<p>SUM函数计算某一指定列的所有行的总和。财务部门可以通过对annual_salary应用这个函数计算年工资总开销。</p>
<blockquote>
<p>计算一列的总和</p>
</blockquote>
<p><code>mysql&gt; select sum(annual_salary) from salaries;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115191855.png" alt="image-20201115191855084"></p>
<p>还可以首先将一些具有同样特征的行分组，然后再利用这些函数对某个类进行计算操作。例如，如果想要查看公司中每一个职位的平均工资，需要使用AVG函数，并且根据员工的职位进行分组。</p>
<blockquote>
<p>使用GROUP BY 子句</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select e.title,avg(s.annual_salary)</span><br><span class="line">   from emplyees e</span><br><span class="line">   join salaries s</span><br><span class="line">   on e.employee_number&#x3D;s.employee_number</span><br><span class="line">   group by e.title;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115192715.png" alt="image-20201115192715794"></p>
<p>在查询中包含了title列之后，需要指定GROUP BY子句，否则数据库不知道如何为不同的职位组织数据。如果没有这个子句，则产生的数据是无意义的：计算了年度工资栏的平均值，然后将原表中的第一行数据（即CEO)用作title列。</p>
<blockquote>
<p>注意：上述示例中使用的表和列都包含一些很长很啰嗦的名字。上面的代码清单使用表定别名，别名的作用是可以在查询过程中对表重命名，在这个例子中将表重命名为更短的名字。</p>
<p>如果要将一个表和自己连接，那么需要为每一个表创建一个别名，否则在连接或使用WHERE子句时数据库不知道引用的是哪一个实例。</p>
</blockquote>
<p><u><strong><em>怎样将数据持久化到数据库中？</em></strong></u></p>
<p>到现在为止，我们只是通过SQL查询表中已有的数据。通过INSERT语句可以向表中插入数据，通过UPDATE语句可以修改已有的行，通过DELETE语句可以删除行。</p>
<p>INSERT语句包含要插入某张表的数据：</p>
<p><code>INSERT INTO emplyees VALUES （1，&#39;Bob Smith&#39;,&#39;CEO&#39;,&#39;1,Pine Drive&#39;,CURDATE(),1);</code></p>
<p>插入多行数据可以使用同样的方法，提供的是用逗号隔开的表示行的元素的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO emplyees VALUES</span><br><span class="line">(2,&quot;Alice Smith&quot;,&quot;CEO&quot;,&quot;1,Pine Drive&quot;,CURDATE(),1),</span><br><span class="line">(3,&quot;Cassandra Williams&quot;,&quot;Developer&quot;,&quot;336,Cedar Court&quot;,CURDATE(),2),</span><br><span class="line">(4,&quot;Dominic Taylor&quot;,&quot;Receptionist&quot;,&quot;74A,High Road&quot;,CURDATE(),2),</span><br><span class="line">(5,&quot;Eric Twinge&quot;,&quot;Developer&quot;,&quot;29,Acacia Avenue&quot;,CURDATE(),1);</span><br></pre></td></tr></table></figure>

<p>还可以插入行的部分内容，前提是没有提供列用NULL代替不会影响约束条件，或者是有默认值。在语句中要给出具体要更新的列：</p>
<p><code>INSERT INTO emplyees(employee_number,name,title,office_location_id)</code></p>
<p><code>VALUES(6,&quot;Frank Roberts&quot;,&quot;Developer&quot;,&quot;2&quot;);</code></p>
<p>更新数据时，需要指定具体要更新的列以及新的值，还可以提供表示要更新的行的匹配条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE emplyees</span><br><span class="line">set home_address&#x3D;&quot;37,King Steet&quot;</span><br><span class="line">where employee_number&#x3D;6;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115201145.png" alt="image-20201115201144928"></p>
<p>如果通过主键匹配行，那么根据定义，只更新一行数据，因为主键唯一标识一行。此外，表也会针对主键建立索引，因此数据库应该可以瞬时定位要跟滚动行。</p>
<p>如果在UPDATE语句中提供了WHERE子句，那么更新操作会针对所有行进行。</p>
<p>删除行也可以通过WHERE子句来指定要删除的行：</p>
<p>DELETE FROM emplyees WHERE name=”Frank Roberts”;</p>
<p>一定要小心！如果忽略了WHERE子句，那么所有的行都会被删除；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from emplyees;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115202042.png" alt="image-20201115202041953"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from emplyees;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115202255.png" alt="image-20201115202255794"></p>
<p>如果要修改表中的数据，总是应该使用事务。这样的话，在提交事务之前，数据库允许你ROLLBACK(回滚)任何错误。</p>
<p><strong><u><em>什么是视图？</em></u></strong></p>
<p>为了方便起见，我们可以将一个常用的查询或连接设置为一个“虚拟表”，这个虚拟表称为视图（view)。对于需要在数据库控制台直接运行多个查询的开发者或者运维人员来说，视图往往可以提供帮助。</p>
<p>如果经常需要通过一条查询来查找员工及其工作地点，那么通过下面的语句可以创建一个反映这些信息的视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW employees_and_locations AS</span><br><span class="line">SELECT employee_number,name,location_name,address</span><br><span class="line">FROM emplyees</span><br><span class="line">JOIN office_location</span><br><span class="line">ON emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p>然后就可以向普通表一样查询这个视图了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees_and_location;</span><br></pre></td></tr></table></figure>

<p>还可以从一个视图中删除数据行。当然，引用完整性的一般性原则在这里也要遵循。此外还可以添加行。如果视图定义中的列有缺失，那么会使用NULL值。如果对应的列不允许使用NULL值，那么这一行数据就不能插入到视图中。</p>
<p>一般情形下，不建议从视图中删除数据。试图太轻量级了，很容易修改其定义，因此当某个列定义从视图中移除时很容易连带地插入NULL值。</p>
<p><strong><em>==DDL和DML是什么?==</em></strong></p>
<p>到目前为止，我们讨论的例子仅仅和数据的操纵有关。SQL还可以用于创建，删除和修改表。数据操纵语言（Data Manipulation Language,DML)通过SELECT,INSERT,UPDATE和DELETE关键字操纵数据。数据定义语言(Data Definition Language,DDL)的用途则是创建和操纵表的结构。</p>
<p>创建表的语句是CREATE TABLE语句。这个语句包含了列的列表以及每一列的数据类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE meeting_rooms (</span><br><span class="line">    -&gt; meeting_room_id   INT,</span><br><span class="line">    -&gt; office_location_id  INT,</span><br><span class="line">    -&gt; meeting_room_name VARCHAR(100)</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure>

<p>这条语句会创建一个带有3个列的表，其中两个列的类型为INT，另外一列的类型为VARCHAR(100),即最长为100个字符的字符串。注意，不同数据中的合法数据类型可能会有所不同。你需要在数据库供应商提供的最新文档中查看哪些类型是合法的。</p>
<p>在这个表中尽管有一个名为office_location_id的列，但是没有指向office_locations表的引用，在此列中没有针对可接受数据的引用完整性规则。</p>
<p>如你所想，DDL不只可以创建表，还可以修改表的定义，例如添加一个列：</p>
<p><code>ALTER TABLE meeting_rooms ADD COLUMN telephone_extension VARCHAR(100);</code></p>
<p>对meeting_rooms表执行SELECT操作时会显示这一列，就好像这一列一直存在一样。如果这个表已经有数据了，那么这一列就会为空，因此显示一个NULL值。在ALTER TABLE语句中可以指定默认值。</p>
<p>要删除(drop)一列，可以运行下列语句：</p>
<p><code>ALTER TABLE meeting_rooms</code></p>
<p><code>ADD FOREIGN KEY (office_location_id)</code></p>
<p><code>REFERENCES office_locations(office_locaton_id);</code></p>
<p>创建了这个约束之后，只有合法的office_location_id值才能插入meeting_rooms表中的那一列。如果在这一列中已经有数据不满足约束条件，那么这条语句会被拒绝。</p>
<p>还可以增加其他任何类型的约束。例如定义一个不允许NULL值的列，或定义一个列只允许接受某个范围内的整数值。</p>
<p><strong><u><em>如何加速低效的查询？</em></u></strong></p>
<p>看一下之前的employees表，记录会按顺序保存在磁盘上，很可能是按照employee_number列的顺序保存的，因此101号员工的数据会保存在100号员工之后，以此类推。</p>
<p>在大部分情况下，通过这种方式保存数据是意义不是太大，因为很少有情况需要根据员工工号的顺序获得员工列表。</p>
<p>针对这些数据的一个可能的查询是查找所有在某个特定办公地点工作的员工：</p>
<p><code>SELECT * FROM employees WHERE office_location_id=2;</code></p>
<p>此查询需要按顺序检查每一行是否满足WHERE子句。如果表中有数千行数据时，这条查询会耗费一阵子时间，特别是在没有任何一行于条件匹配时。</p>
<p>通过给这一列增加索引，数据库可以直接查询这一列，得到指向行位置的直接引用。</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115212423.png" alt="image-20201115212423252"></p>
<p>这张表还会额外保存office_location_id 的分组信息，数据库会通过这些信息查找办公地点对应的数据行。这里需要付出的代价是需要更多的磁盘空间来保存这些索引</p>
<blockquote>
<p>创建索引</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index office_loc_idx on employees(office_location_id);</span><br></pre></td></tr></table></figure>

<p>创建了索引之后，向employees表插入数据时还会在索引中创建一个条目，可能会导致插入数据耗费的时间更长。带来的好处是查询更快了，特别是在表增长到数千行的规模时。</p>
<p><strong><em>==如果SQL不能满足需求怎么办？==</em></strong></p>
<p>存储过程(stored procedure)提供的功能比SQL 提供的简单创建，读取，更新和删除功能更为强大。在存储过程中可以执行更多的过程式步骤。</p>
<p>下面给出一个需要创建存贮过程的例子：为超过一年没有加薪的员工加薪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE annual_salary_raise (</span><br><span class="line">   IN percent INT,</span><br><span class="line">   OUT total_updated INT</span><br><span class="line">   )</span><br><span class="line">   BEGIN</span><br><span class="line">   SELECT COUNT(*)</span><br><span class="line">   INTO total_updated</span><br><span class="line">   FROM salaries</span><br><span class="line">   WHERE last_update_date&gt;DATE_SUB(CURDATE(),INTERVAL 1 YEAR);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE salaries</span><br><span class="line">SET annual_salary&#x3D;annual_salary*((100+percent)&#x2F;100),</span><br><span class="line">    last_update_date&#x3D;CURDATE()</span><br><span class="line">WHERE last_update_date&gt;DATE_SUB(CURDATE(),INTERVAL 1 YEAR);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>这个存储过程接受两个参数：一个IN参数，表示工资增长的百分数：一个OUT参数，可以看成是存储过程的返回值。这里传入一个语柄，存储过程通过语柄设置值，然后再运行完存储过程之后就可以通过语柄读取值。在这个例子中，OUT参数保存的是更新的行数。IN参数和OUT参数的数目可以根据自己的需求随意指定。</p>
<p>SELECT 语句的形式也不相同，将COUNT函数的结果填入total_updated OUT参数。如果SELECT语句返回0行或多余1 行数据，则这条查询会失败。</p>
<p>这个存储过程对那些已经超出一年没有更新的行应用百分比更新。MySQL提供了一个用于操纵DATE数据类型的DATE_SUB函数——-这个例子中，这个函数计算的是CURDATE(表示今天的日期)之前一年的日期。这条更新语句还会将最后更新的日期设置为CURDATE，因此被更新的行在一年之内不会被更新。</p>
<blockquote>
<p>调用MySQL存储过程，实现4%的涨薪</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select curdate();</span><br><span class="line"></span><br><span class="line">mysql&gt;select * from salaries;</span><br><span class="line"></span><br><span class="line">mysql&gt;call annual_salary_raise(4,@updated_count);</span><br><span class="line"></span><br><span class="line">mysql&gt;select * from salaries;</span><br><span class="line"></span><br><span class="line">mysql&gt;select @updated_count;</span><br></pre></td></tr></table></figure>

<p>存储过程特别适合于批量操作一系列语句，通过某种定制的方式操纵数据，上述存储过程就是这样一个例子。另一种用法是在触发器（trigger）中使用。当某个特定的数据库事件发生时，例如删除或更新一行数据时，可以配置在动作发生之前或之后运行一个存储过程，也可以用一个存储过程替代相应的动作。</p>
<p>触发器的一个实际用法是记录数据库事件。当一个敏感的表（例如记录员工工资的财务表）被更新时，可以设置一个存储过程，在向这张表插入数据之前和之后向一张辅助的审计表中插入数据，如果事后有任何分歧时可以在审计表中有据可查。</p>
<p><strong><em>==什么是事务？==</em></strong></p>
<p>上上个代码所展示的存储过程存在一个问题，即OUT参数中返回的更新的行数可能和实际更新的行数不一致。这个存储过程执行了两个操作：首先，计算要更新的行的数目，然后执行实际的更新操作。如果有一个客户在运行annual_salary_raise存储过程的同时，另一个客户对salaries表进行更新并且更新的数据会被存储过程中的更新语句影响，那么第二个客户的更新操作可能会发生在第一个客户通过SELECT统计行数之后，第一个客户通过UPDATE更新薪资数据之前。</p>
<p>通过将这个过程事务化，就可以避免以上竞争条件的发生。</p>
<p>不论在什么领域(数据库领域或者其他领域)中，事务(transaction)都要满足4个条件，这个条件统称为ACID：</p>
<ul>
<li><p><strong>原子性</strong>(Atomic)——–事务中的内容要么全部以一个 整体完成，要么完全没有做。不可能在数据库中看到事务只执行了一半的状态。</p>
</li>
<li><p><strong>一致性</strong>(Consistent)——–执行完事务之后，数据库满足作用域的所有要求。例如，当有两方进行支付时，从一方借记的金额应该匹配另一方存入的金额。</p>
</li>
<li><p><strong>隔离性</strong>(Isolated)———每一个并行运行的事务其行为看上去都应该好像只有这一个事务在数据库中运行。</p>
</li>
<li><p><strong>持久性</strong>(Durable)———事务一旦被提交之后，就永久地提交了。数据库中任何后续的修改，例如更新或崩溃，都不会对已提交的事务造成影响。</p>
</li>
<li><p>为了将上上个代码中存储过程持久化，必须通过START TRANSACTION语句开始一个事务，并最终通过COMMIT语句成功提交事务。</p>
<blockquote>
<p>使用事务</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE annual_salary_raise_transactional (</span><br><span class="line">	IN percent INT,</span><br><span class="line">	OUT total_updated INT</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	START TRANSACTION;</span><br><span class="line">	SELECT COUNT(*)</span><br><span class="line">	...</span><br><span class="line">	...&lt;参见上上个代码&gt;</span><br><span class="line">	...</span><br><span class="line">	WHERE last_update_date&lt;DATE_SUB(CURDATE(),INTERVAL 1 YEAR);</span><br><span class="line">	COMMIT;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>当事务在运行时，其他连接在尝试更新salaries表时都会被阻塞，直到这个事务完成执行。</p>
<p>在运行存储过程的过程中，如果发现数据库处在不一致的状态，或者存储过程中有一些条件没有满足，可以自己中止事 务。通过ROLLBACK（回滚）语句种植事务。</p>
<p>回滚通常是由数据库日志管理的，回滚时反向执行从事务开始时的所有日志。其他运行的事务可能依赖于被回滚的事务的结果，在这种情况下，这些依赖的事务也会被回滚。</p>
<p><strong><em>==什么是NoSQL==</em></strong></p>
<p>NoSQL是一个覆盖性的术语，指的是所有不严格遵循关系式数据库模型的数据库。这些数据库处理的通常是非范式化的数据，通常以键-值对，全文档或图的形式保存数据，目的是让数据的检索速度尽可能地块，从而使得应用程序的相应能力更强。在操纵海量数据时，例如TB级的数据甚至PB级的数据时，对相应能力有特别的要求。</p>
<p>在NoSQL领域，没有和SQL对应的访问标准，因为每一个数据库都以自己的方式存储数据。NoSQL的一个缺点就是一旦开始使用某个NoSQL数据库产品，那么就会被绑定到某个特定的厂商，因为迁移的过程需要在不同数据库的模型之间映射，因此会有特异性而且非常费劲。</p>
<p>下面是一些流行的NoSQL数据库产品：</p>
<ul>
<li>MognoDB——-数据以JSON对象的形式保存，而且类似的对象之间不一定有相同的字段。</li>
<li>Cassandra———数据保存在列族(column family)中。和表类似，但是不要求所有的行有相同的列。</li>
<li>Memcached———分布式键-值存储缓存。</li>
<li>Redis———集群化的持久键-值存储。</li>
</ul>
<h2 id="JDBC-整合Java和数据库"><a href="#JDBC-整合Java和数据库" class="headerlink" title="JDBC:整合Java和数据库"></a>JDBC:整合Java和数据库</h2><p><strong><em>==如何通过Java连接一个关系数据库？==</em></strong></p>
<p>Java Database Connectivity(JDBC)是构建在Java标准库连接机制。在使用JDBC连接数据库时，必须确保供应商的JDBC实现位于classpath中。在Java6之前，需要通过调用Class.forName(“<Vendor class>“)确保类加载器已经加载了数据库供应商为JDBC编写的驱动程序。现在这个过程已经被服务提供者机制自动化了，后者会在JAR的META-INF/services目录中提供一个查找项。</p>
<p>要创建连接，必须以URL的形式向JDBC提供相关的连接参数</p>
<blockquote>
<p>验证一个活跃的数据库连接</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectToDb</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Connection connection=DriverManager.getConnection(</span><br><span class="line">				<span class="string">&quot;jdbc:mysql://localhost:3306/company_db&quot;</span>,<span class="string">&quot;nm&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		assertFalse(connection.isClosed());</span><br><span class="line">		connection.close();</span><br><span class="line">		assertTrue(connection.isClosed());</span><br></pre></td></tr></table></figure>

<p>传递给DriverManager.getConnection的连接字符串传入了一个名为company_db的数据库的完整URL，这个数据库运行在本地服务器上，端口号默认的330户名为nm，密码为password。这个测试证实了可以创建连接，验证连接成功，然后关闭连接。</p>
<p><strong><em>==如何通过Java执行SQL查询？==</em></strong></p>
<p>建立好了数据库连接后，就可以通过执行SQL操作来检索和操纵数据。</p>
<blockquote>
<p>通过JDBC查询数据库，并将查询结果填入普通的Java类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retrieveRows</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Connection connection=DriverManager.getConnection(</span><br><span class="line">				<span class="string">&quot;jdbc:mysql://localhost:3306/company_db&quot;</span>,</span><br><span class="line">				<span class="string">&quot;nm&quot;</span>,</span><br><span class="line">				<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		<span class="keyword">final</span> java.sql.Statement stmt=connection.createStatement();</span><br><span class="line">		<span class="keyword">final</span> ResultSet rs=stmt.executeQuery(</span><br><span class="line">				<span class="string">&quot;select employee_number,name from employees&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Map&lt;Integer,String&gt; employeeMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> employeeNumber=rs.getInt(<span class="string">&quot;employee_number&quot;</span>);</span><br><span class="line">			<span class="keyword">final</span> String name=rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">			employeeMap.put(employeeNumber,name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Map&lt;Integer,String&gt; expectedMap=<span class="keyword">new</span> HashMap&lt;Integer,String&gt;()&#123;&#123;</span><br><span class="line">			put(<span class="number">1</span>,<span class="string">&quot;Bob Smith&quot;</span>);</span><br><span class="line">			put(<span class="number">2</span>,<span class="string">&quot;Alice Smith&quot;</span>);</span><br><span class="line">		&#125;&#125;;</span><br><span class="line">		</span><br><span class="line">		assertEquals(expectedMap,employeeMap);</span><br><span class="line">		</span><br><span class="line">		rs.close();</span><br><span class="line">		stmt.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>数据库连接提供了语句，语句运行查询，查询返回结果集。</p>
<p>ResultSet接口具有类似Iterator的访问方式。当ResultSet实例打开时，数据库有一个打开的游标(sursor),每一次调用next时都会将游标移动至下一行。这个方法返回一个Boolean值，如果返回false则表明该查询中没有更多的行。</p>
<p>每一个数据库厂商都提供了自己的JDBC类的实现，例如Statement，ResultSet和Connection类。因此，厂商应该自行提供从数据库数据类型到Java类型的映射。通常情况下，这都不会是大问题，因为大部分数据类型都有逻辑上等价的类型。在上述代码中，employee_number列是MySQL数据库中的Integer类型，因此对ResultSet调用getInt会将数据转换为Java的int类型。类似的，name列的类型是VARCHAR，它会被映射为一个String。</p>
<p>getXXX方法是被重载的方法，可以接受表示列名字符串作为参数，也可以接受表示列索引（从1开始）的int作为参数。</p>
<p><strong><em>==如何避免SQL注入攻击？==</em></strong></p>
<p>如果有某条查询需要反复运行，数据库可以协助完成查询准备，从而得到更快且更安全的查询。</p>
<p>使用查询参数（query parameter）可以让数据库编译查询，并对查询做好预处理然后只要提供参数就可以执行实际的查询。</p>
<blockquote>
<p>使用查询参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryParameters</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> PreparedStatement pStmt=conn.prepareStatement(</span><br><span class="line">				<span class="string">&quot;insert into office_locations values (?,?,?,NULL)&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Map&lt;String,String&gt; locations=<span class="keyword">new</span> HashMap&lt;String,String&gt;()&#123;&#123;</span><br><span class="line">			put(<span class="string">&quot;London&quot;</span>,<span class="string">&quot;picadilly Square&quot;</span>);</span><br><span class="line">			put(<span class="string">&quot;New York&quot;</span>,<span class="string">&quot;Union Plaza&quot;</span>);</span><br><span class="line">			put(<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Revolution Place&quot;</span>);</span><br><span class="line">		&#125;&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (String location:locations.keySet()) &#123;</span><br><span class="line">			pStmt.setInt(<span class="number">1</span>,i);</span><br><span class="line">			pStmt.setString(<span class="number">2</span>,location);</span><br><span class="line">			pStmt.setString(<span class="number">3</span>,locations.get(location));</span><br><span class="line">			pStmt.execute();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		pStmt.close();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Statement stmt=conn.createStatement();</span><br><span class="line">		<span class="keyword">final</span> ResultSet rs=stmt.executeQuery(</span><br><span class="line">				<span class="string">&quot;select count(*) from office_locations&quot;</span>+</span><br><span class="line">		<span class="string">&quot;where location_name in(&#x27;London&#x27;,&#x27;New York&#x27;,&#x27;Paris&#x27;)&quot;</span>);</span><br><span class="line">		assertTure(rs.next());</span><br><span class="line">		assertEquals(<span class="number">3</span>,rs.getInt(<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		rs.close();</span><br><span class="line">		stmt.close();</span><br></pre></td></tr></table></figure>

<p>在上上一个代码中，查询是通过一个Statement对象执行的，但是在这个例子中，查询使用了一个PreparedStatement对象。创建一个PreparedStatement对象时，需要提供要运行的查询。不同的查询调用要使用的变量参数通过问号表示。</p>
<p>每一次要执行查询时，通过setXXX方法设置参数，指明查询中对应数据的类型。setXXX方法可以看成是ResultSet中对应的getXXX。同样，要注意这里的参数索引是从1而不是0开撕的。</p>
<p>使用带有特定数据类型的setXXX方法而不是将参数值硬编码为String可以实现一定程度的安全性，避免类似SQL注入这类攻击。</p>
<p>假设有一个Web服务要根据某一个列的ID显示数据库中的内容。这个网络服务是URL可能具有这样的形式：/showResults?id=3。这个网络服务可以简单地实现：接收解析后的查询参数，然后放在查询内直接传入数据库：</p>
<p><code>stmt.excuteQuery(&quot;select * from records where id=&quot;+queryParameters.get(&quot;id&quot;));</code></p>
<p>然而，恶意的用户可以将id参数的值替换为“3；DROP TABLE USERS;”。这样的话，以上代码就变成了两条查询：</p>
<p><code>SELECT * FROM records WHERE id=3;DROP TABLE users;</code></p>
<p>如果刚好不幸有一个名为users的表，那么这个表就会被删除。</p>
<p>然而如果这个查询是通过PreparedStatement执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> PreparedStatement ps=conn.prepareStatement(<span class="string">&quot;select * from records where id=?&quot;</span>);</span><br><span class="line">ps.setInt(<span class="number">1</span>,queryParameter.get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">ps.execute();</span><br></pre></td></tr></table></figure>

<p>当查询参数尝试将值设置为int’时，会在运行时抛出异常，因为恶意的字符串无法转换为int。</p>
<p>对于要进入数据库的输入，总是应该进行审查，而且只要条件允许，就尽量使用类型系统的帮助。</p>
<p><strong><em>==如何通过Java运行存储过程？==</em></strong></p>
<p>调用存储过程的方式和创建预处理语句的方式类似。通过下面的代码测试可以运行之前定义好的salary_update存储过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tes</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callStoresProc</span><span class="params">()</span> <span class="keyword">throws</span> SQLExcepton </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CallableStatement stmt =conn.prepareCall(<span class="string">&quot;&#123;call</span></span><br><span class="line"><span class="string">          annual_salary_raise(?,?)&#125;&quot;</span>);</span><br><span class="line">          stmt.setInt(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">          stmt.registerOutParameter(<span class="number">2</span>,Types.INTEGER);</span><br><span class="line">                                                   </span><br><span class="line">          stmt.execute();</span><br><span class="line">                                                   </span><br><span class="line">          <span class="keyword">int</span> updatedEmployees=stmt.getInt(<span class="number">2</span>);</span><br><span class="line">          assertEquals(<span class="number">1</span>,updateEmployees);                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个测试，假定在运行之前，数据库中只有一名员工满足涨薪条件。</p>
<p>对Connection对象调用prepareCall创建了一个CallableStatement对象。和Prepared-Statement对象类似，这里提供的是要在数据库中运行的语句，参数用问好表示。</p>
<p>所有不同的参数都要设置，同时设置数据类型。注意JDBC对输出参数是区别对待的。在语句执行结束之后收集这些输出参数的值。</p>
<p>调用存储过程的字符和具体的数据库相关：</p>
<p><code>&#123;call ANNUAL_SALARY_RAISE(?,?)&#125;</code></p>
<p>对于不同的厂商，这个字符串的结构会有所不同。要注意不同厂商发起调用的方式可能不同。例如，在Oracle PL/SQL中调用同名存储过程的字串如下所示：</p>
<p><code>conn.prepareCall(&quot;BEGIN ANNUAL_SALART_RAISE(?,?);END;&quot;);</code></p>
<p>这个调用是由BEGIN…END块而不是花括号包围。参数仍然通过问号来设置。</p>
<p><strong><em>==如何管理数据库连接==</em></strong></p>
<p>数据库的连接是一种源，而且创建连接的过程非常耗时，特别是连接需要在网络上协商建立时。创建数据库连接的过程往往比数据库操作本身还要耗时。</p>
<p>和线程池采用的方法类似，应用程序通常会管理一个数据库连接池。</p>
<p>有多个开源的库能够创建和管理连接池。这些库都遵循类似的方式：你要告诉库关于连接建立的细节，然后需要连接时，库就可以提供连接。库既可能创建一个新的连接，也可能会重用一个之前创建的连接，从而节省建立连接的时间。</p>
<p>C3P0是一个管理连接的开源项目。</p>
<blockquote>
<p>使用连接池</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionPools</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ComboPooledDataSource cpds=<span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/company_db&quot;</span>);</span><br><span class="line">cpds.setUser(<span class="string">&quot;nm&quot;</span>);</span><br><span class="line">cpds.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="keyword">final</span> Connection conn=cpds.getConnection();</span><br><span class="line">    <span class="keyword">final</span> Statement stmt=conn.createStatement();</span><br><span class="line">    <span class="keyword">final</span> ResultSet rs=stmt.executeQuery(</span><br><span class="line">    <span class="string">&quot;select count(*) from office_locations&quot;</span>+</span><br><span class="line">    <span class="string">&quot;where location_name in (&#x27;London&#x27;,&#x27;New York&#x27;,&#x27;Paris&#x27;)&quot;</span>);</span><br><span class="line">    assertTure(rs.next();</span><br><span class="line">              assertEquals(<span class="number">3</span>,rs.getInt(<span class="number">1</span>));</span><br><span class="line">               </span><br><span class="line">               DataSources.destroy(cpds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结束操作时不要关接池保存了对其创建的连接的引用，并且会周期性地通过一条简单的查询（例如SELECT 1 或者 SELECT 1 FROM DUAL 等，取决于具体的数据库）检查连接的健康状况。</p>
<p>使用连接池的好处是让应用程序更能应对数据库中止服务的情形。如果数据库崩溃或者重启，则所有的连接都会丢失，因此这些连接的所有引用都会失效，当应用程序对象对这些连接发出新请求时，连接池会对重启后的数据库创建新的连接，因为连接池会探测到旧的连接已不可用。</p>
<p><strong><em>==如何管理应用程序的数据库发布==</em></strong></p>
<p>发布Java应用程序时，通常是以单元的方式构建和发布应用程序，任何升级也是一个整体的形式进行升级，用升级版本替换现有的二进制版本。</p>
<p>而对于数据库来说并不总可以这么做，因为数据库中存储的数据必须在版本之间持久存在。</p>
<p>幸好，有一些可以和现有构建系统很好地整合的工具，这些工具可以管理和执行数据库部署和升级。</p>
<p>DBDeploy就是这样一种工具，这个工具可以直接和Maven或Ant协作。</p>
<p>每一次要在新版本中修改数据时，请在构建中添加一个带计数的文件，这个计数比上一次数据库变更文件的计数大1.DBDeploy在数据库中管理一个表，在一个名为changlog的表中记录运行脚本的列表。如果DBDeploy发现在changelog表中有任何没有被记录的文件，那么DBDeploy就会按照数字顺序执行这些脚本。</p>
<p>之后再次运行DBDeploy就会忽略这些文件，因为这些文件被记录为已经成功执行过。</p>
<h2 id="利用内存数据库进行测试"><a href="#利用内存数据库进行测试" class="headerlink" title="利用内存数据库进行测试"></a>利用内存数据库进行测试</h2><p><strong><em>==在开发数据库时能不能维护一个一致的环境？==</em></strong></p>
<p>在对一个需要访问数据库的应用程序进行活跃开发时，不容易将数据库维持在一个可维护的状态。有一种方法是使用一个和产品和集成环境中不同的数据库发行版：内存数据库。</p>
<p>顾名思义，内存数据库中的内容在JVM关闭时会丢失。因此特别适合使用测试数据，因为我们并不关心测试数据的持久化，而是更关心应用程序和数据库之间的交互是否符合预期。内存数据库也运行在本地机器，因此也不需要管理网络流量，数据库也不需要处理多个客户端的复杂连接问题。</p>
<p>一些开源的关系数据库提供了和SQL兼容的内存选项，H2就是一个这样的数据库。H2的设计很简单，不需要特别的代码启动数据库，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectToH2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Connection conn=DriverManager.getConnection(</span><br><span class="line">    <span class="string">&quot;jdbc:h2:mem:test;MODE=MySQL&quot;</span>,<span class="string">&quot;nm&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> Statement stmt=conn,createStatement();</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;create table teams(id INTEGER,name VARCHAR(100))&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;insert into teams values(1,&#x27;Red Team&#x27;)&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;insert into teams values(2,&#x27;Blue Team&#x27;)&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;insert into teams values(3,&#x27;Green Team&#x27;)&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> ResultSet rs=stmt.executeQuery(<span class="string">&quot;select count(*) from teams&quot;</span>);</span><br><span class="line">    assertTure(rs.next());</span><br><span class="line">    assertEquals(<span class="number">3</span>,getInt(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>H2通过连接字串jdbc:h2:mem:test就可以创建名为test的内存数据库，操作行为和其他JDBC连接是一样的。teams表只有在测试运行时才可用——-这个表没有保存在任何位置，因此这个测试每一次都可以运行成功。如果连接的是真实数据库，那么在运行任何针对teams表的测试之前，都要确定这个表的当前状态。username和password参数在这里不重要。</p>
<p>通过配置连接字串中设置可以自定义数据库的行为。连接字串jdbc:h2:mem;test;MODE=MySQL表示要求H2数据库理解MySQL的特性，即MySQL数据类型以及MySQL特有的SQL语言特性。</p>
<p>将内存数据库和DBDeploy结合使用，在测试集运行之前可以将DBDeploy脚本导入新创建的H2数据库，然后测试就可以像连接到普通MySQL数据库一样运行。</p>
<p>另外一种针对真实关系数据库测试的方式是打开的事务中运行，然后再测试结构（不论失败还是成功）时回滚事务。这种测试方式可能很高效，但是有风险。如果测试中会提交事务，那么就不能通过这种方式测试。此外，这种测试也依赖于真确的数据库状态。</p>

    </div>

    

    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a target="_blank" rel="noopener" href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/11/15/Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B4%E5%90%88/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/11/09/Java%E5%9F%BA%E7%A1%80/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/11/06/%E9%9B%86%E5%90%88/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/11/03/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Untitled</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://telegram.org/">
                            <span class="footer-icon-container">
                                <i class="fa fa-telegram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>