<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Java基础原始类型Java中的基本类型，例如boolean，int，和double等都成为原始类型（primitive type）JVM处理这些类型的方式和处理引用类型（reference type）的方式是不同的，引用类型也成为对象（object）。原始类型总会有一个值，绝不可能是null。
当">
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="wsh549"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="wsh549"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>wsh549</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="wsh549" type="application/atom+xml">
</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2020/11/09/Java%E5%9F%BA%E7%A1%80/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-11-09</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>Java中的基本类型，例如boolean，int，和double等都成为原始类型（primitive type）JVM处理这些类型的方式和处理引用类型（reference type）的方式是不同的，引用类型也成为对象（object）。原始类型总会有一个值，绝不可能是null。</p>
<p>当定义一个int和long类型的变量时，编译器需要区分这两种类型。你需要做的是在long值后面添加L后缀。如果没有L，则表示值是int。L既可以大写也可以小写，但建议大写，因为这样可以帮助读代码的人轻松区分字母L和数字1.对于float和double值也是如此：float可以通过F定义，而double可以通过D定义。对于double来说，后缀是可选的，省略后缀表示double。</p>
<table>
<thead>
<tr>
<th align="center">原始类型</th>
<th align="center">大小（位）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16</td>
</tr>
</tbody></table>
<p>char是无符号的，也就是说，char的取值范围是0~65535，因为char可以表示Unicode值。</p>
<p>如果原始变量在定义时没有设置值，那么会使用一个默认值，boolean值的默认值是false。对于其他类型的值，默认是0的一种表示方式，例如int的默认值为0，float的默认值为0.0f。</p>
<p>必要时，编译器可以将值向上转换至恰当的类型，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value=Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">long</span> biggerValue=value+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>除了char类型的变量之外，编译器会自动使用更宽的类型表示变量，因为不会丢失任何精度，例如从int提升至long，以及从float提升至double。而反过来则不行。如果试图将一个long值赋给int，则必须对这个进行显示类型转换。显示类型转换告诉编译器这确实是我希望做的，而且不会在乎丢掉精度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> veryLargeNumber=Long.MAX_VAUE;</span><br><span class="line"><span class="keyword">int</span> fromLargeNumber=(<span class="keyword">int</span>) veryLargeNumber;</span><br></pre></td></tr></table></figure>

<p>==<em><u>为什么Integer.MIN_VALUE没有对应的正数？</u></em>==</p>
<p>short,int和long的二进制值在内存中存储时采用一种称为二进制补码（Two’s Complement)的形式。</p>
<table>
<thead>
<tr>
<th align="center">十进制</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0000 0000</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0000 0001</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0000 0010</td>
</tr>
</tbody></table>
<p>采用二进制补码表示法时，得到一个正数值对应的负数值的方法是执行二进制NOT操作然后加1.</p>
<p>因为取负值的操作需要两条指令。二进制补码的好处之一是只有一个零，即没有“负数</p>
<p>零”的概念。因而系统可以多存储一个负值。</p>
<table>
<thead>
<tr>
<th align="center">十进制</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-1</td>
<td align="center">1111 1111</td>
</tr>
<tr>
<td align="center">-1</td>
<td align="center">1111 1110</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">-127</td>
<td align="center">1000 0000</td>
</tr>
<tr>
<td align="center">-128</td>
<td align="center">1000 0000</td>
</tr>
</tbody></table>
<p>能存储的绝对值最大的负数的最高有效位是1，其他位都为0.对这个值取负数</p>
<p>操作：将所有的位取反得到（0111 1111），然后加1（得到1000 0000），最后得到的还是原始值，没有对应的正数！如果确实有必要使用这个值的正数，可以使用更宽的类型，例如long，或者更复杂的引用类型BigInteger，后者可以认为是没有上界的。</p>
<p>如果执行的计算产生的结果大于Inter.MAX_VALUE或小于Integer.MIN_VALUE,那么只有低32位会被保存，这种情况下会产生错误的结果。这种现象称为溢出（overflow）。</p>
<p>不能通过int类型表示Integer.MIN_VALUE的绝对值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">absoluteOfMostNegativeValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mostNegative=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> negated=Math.abs(mostNegative);</span><br><span class="line">    assertFalse(<span class="string">&quot;No positive equivalent of Integer.MIN_VALUE&quot;</span>,negated&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><p>==<strong><em><u>Java对象是什么?</u></em></strong>==</p>
<p>对象可以定义为 一组变量的集合和一组方法的集合，这组变量可以看成是整合在一起表示一个复杂的实体，而这组方法提供了和这个实体相关的操作。简而言之，对象是对状态和行为的封装。</p>
<p>除去原始类型之外，Java程序设计语言中的其他变量都死引用类型，更广泛的叫法是对象。对象和原始类型有很大区别，最重要的区别之一就是可以表达对象不存在的情况，即null。变量可以设置为null,方法也可以返回null。如果尝试对null对象调用方法，则会抛出NullPointerException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected=NullPointerException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expectedNullPointerExceptionToBeThrown</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stringLength=s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象都是引用类型，具体表示什么意思呢？在使用原始类型时，如果声明一个变量int i=42,这表示42这个值被赋给了内存中的一个位置。如果程序中后来又给另外一个变量赋予了变量i的当前值，例如 int j =i，那么内存中另一个位置被赋予了同一个值。后续对i的值的修改都不会改变j的值，反之亦然。</p>
<p>在Java中，类似new ArrayList（20)这样的语句在内存中申请一个区域保存数据。当这个创建的对象被赋予给一个变量时，例如List myList=new ArrayLIstanbul（20），那么表示myList指向了那个内存位置。从表面上看，这个行为和原始类型赋值的行为是一样的，但实际上是不一样的。如果多个变量被赋予了同一个对象（成为实例），那么这些变量指向的是同一个内存区域。通过一个变量对这个实例进行任何修改都会被其他变量看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objectMemoryAssignment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    list.add(<span class="string">&quot;entry in list1&quot;</span>);</span><br><span class="line">    assertTure(list1.size()==<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    List list2=list1;</span><br><span class="line">    list2.add(<span class="string">&quot;entry in list2&quot;</span>);</span><br><span class="line">    assertTrue(list1.size()==<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><u><strong>==final关键字对对象引用有什么作用？==</strong></u></em></p>
<p>final关键字的作用对于对象和对于原始类型是一样的。变量定义时设置变量的值，然后变量表示的内存位置存储的值不能变化。尽管对象引用不能变化，但是这个对象中的值可以变化，除非这些值本身都是final的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalReferenceChanges</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line">    <span class="comment">//i=43;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//list=new ArrayList(50);</span></span><br><span class="line">    assertEquals(<span class="number">0</span>,list.size());</span><br><span class="line">    </span><br><span class="line">    list.add(<span class="string">&quot;adding a new value into my list&quot;</span>);</span><br><span class="line">    assertEquals(<span class="number">1</span>,list.size());</span><br><span class="line">    </span><br><span class="line">    list.clear();</span><br><span class="line">    assertEquals(<span class="number">0</span>,list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<u><em>对象中的可见性修饰符（visibility modifier）有什么作用？</em></u>==</p>
<p>可见性修饰符控制的是对类中的封装的状态以及控制实例行为的方法的访问权。对象中封装的变量和方法是由四种类型的修饰符控制的。</p>
<table>
<thead>
<tr>
<th align="center">可见性</th>
<th align="center">修饰符</th>
<th align="center">可见范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最低</td>
<td align="center">private</td>
<td align="center">同一个类的任何实例可见，子类不可见</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><none></td>
<td align="center">同一个包中的任何类可见</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">protected</td>
<td align="center">任何子类可见</td>
</tr>
<tr>
<td align="center">最高</td>
<td align="center">public</td>
<td align="center">任意位置可见</td>
</tr>
</tbody></table>
<p>记住，private成员变量只能在所有的内使用，甚至不能在子类中访问：private变量就应该用于所在的类本身，而不能用于其他任何类。</p>
<p>关于private修饰符有一个常见的误解，那就是认为private变量只能被所在的实例访问。事实上，实例可以访问同一个类型的其他任意实例的private成员变量。</p>
<p>访问同一个类型不同实例的private成员变量的两种情形。大部分优秀的集成开发环境都会帮助生成hashCode和equals方法：这些方法在判定实例是否相等时都会访问其他实例的private成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> real;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> imaginary;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Complex</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> r,<span class="keyword">final</span> <span class="keyword">double</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.real=r;</span><br><span class="line">        <span class="keyword">this</span>.imaginary=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Complex <span class="title">add</span><span class="params">(<span class="keyword">final</span> Complex other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(<span class="keyword">this</span>.real+other.real,</span><br><span class="line">                          <span class="keyword">this</span>.imaginary+other.imaginary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为简洁省略了hashCode</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==o)</span><br><span class="line">            <span class="keyword">return</span> ture;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="keyword">null</span>||getClass()!=o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        Complex complex=(Complex)o;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Double.compare(complex.imaginary,imaginary,imaginaryy)!=o.getClass())</span><br><span class="line">        <span class="keyword">if</span>(Double.compare(complex.real,real)!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complexNumberAddition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Complex expected=<span class="keyword">new</span> Complex(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Complex a=<span class="keyword">new</span> Complex(<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> Complex b=<span class="keyword">new</span> Complex(-<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    assertEquals(a.add(b),excepted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<strong><em><u>对于方法和变量来说，static修饰符表示什么意思？</u></em></strong>==</p>
<p>类中定义的静态方法和变量属于类，但是不属于某个实例。静态方法和变量是所有实例共享的，通常通过类名来访问，而不是通过某个具体的实例来访问。</p>
<p>类的成员变量既可以通过实例访问也可以通过类本身访问。建议仅通过类名访问静态方法和变量，因为通过实例访问可能会导致混淆：对类定义不熟悉的其他开发者可能会认为这是实例的成员，如果修改了静态变量的值，其他实例会产生异常的行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> EXAMPLE_VALUE=<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">staticVariableAccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    assertEquals(ExampleClass.EXAMPLE_VALUE,<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    ExampleClass c1=<span class="keyword">new</span> ExampleClass();</span><br><span class="line">    ExampleClass c2=<span class="keyword">new</span> ExampleClass();</span><br><span class="line">    c1.EXAMPLE_VALUE=<span class="number">22</span>;<span class="comment">//合法，但不推荐</span></span><br><span class="line">    assertEquals(ExampleClass.EXAMPLE_VALUE,<span class="number">22</span>);</span><br><span class="line">    assertEquals(c2.EXAMPLE_VALUE,<span class="number">22</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态（polymorphism)和继承(inheritance)是什么？</p>
<p>多态和继承是面向对象开发中的两个核心概念。</p>
<p>通过多态可以为某一特定类型的行为进行定义，并且可以针对这种行为提供多种不同的实现类。通过继承，可以在定义一个类时从父类继承行为。</p>
<p>定义新的类时，可以从之前定义的继承定义和状态，然后在自己的类中添加新的行为，或在新的类中覆盖原父类中的行为。</p>
<p>在下面的代码中，Square类继承自Rectangle类（可以说，正方形是一个（is-a）矩形）。在Square的定义中，用于保存边长的变量被重用，而Square类强制width和height保持一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> height;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> width,<span class="keyword">final</span> <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width=width;</span><br><span class="line">        <span class="keyword">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> sideLength)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sideLength,sideLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑之前定义的is-a关系，可以这样看待多态：在访问父类时，实际使用的时一个子类。虽然实际的行为是由子类提供的，但是多态的调用者并不知道这一点。</p>
<p>下面的代码展示了使用多态的Square和Rectangle类。在ArrayList看来，它只是在和Rectangle打交道，它不明白，也没必要明白Rectangle和Square之间的区别。考虑到一个Square就是一个Rectangle，因此这段代码可以正常工作。如果Square类定义了任何特别的方法，那么Rectangle列表的用户无法使用这些方法，因为在Rectangle类中并没有这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">polymorphicList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Rectangle&gt; rectangles=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    rectangles.add(<span class="keyword">new</span> Rectangle(<span class="number">5</span>,<span class="number">1</span>));</span><br><span class="line">    rectangles.add(<span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">10</span>));</span><br><span class="line">    rectangles.add(<span class="keyword">new</span> Square(<span class="number">9</span>));</span><br><span class="line">    </span><br><span class="line">    assertEquals(rectangle.get(<span class="number">0</span>).area(),<span class="number">5</span>);</span><br><span class="line">    assertEquals(rectangle.get(<span class="number">1</span>).area(),<span class="number">20</span>);</span><br><span class="line">    assertEquals(rectangle.get(<span class="number">2</span>).area(),<span class="number">81</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>==<u><strong>解释Object类被继承时一些会被重写的方法。</strong></u>==</em></p>
<p>运行在JVM上的每一个类都是从java.lang.Object继承而来的，因此这个类中所有非final的public和protected方法都可以被重写。</p>
<p>equals（Object other）方法的用途是：测试两个引用表示的对象是否逻辑上相等。对于集合类，例如java.util.TreeSet和java.util.HashMap等，利用对象的equals方法判定对象是否已经在集合中存在。Object实现的equals方法比较的是对象在内存中的位置，如果两个对象在内存中位于同一个位置，那么这两个对象实际上就是同一个对象，因此必然相等。这种比较实际上没有多大用，而且也不应该是判定相等的正确方法，因此在任何需要判定相等的场合都必须重写这个方法。</p>
<p>hashCode的规则是：对于两个相等的对象，必须返回同一个值。==注意，反过来并没有这样的要求==也就是说，如果两个对象返回的是同一个hashCode，不一定意味着两个对象相等。反过来的这项特性本身是挺好的，但是并不强求：不同实例之间的hashCode差异越大，这些实例在HashMap中的分布性就越好。要注意的是，hashCode返回的是一个int，这意味着如果要求不同的hashCode表示不相等的对象，那么某一个类型的实例最多只能由2^32^种不同的值。这是一个很大的限制，特别是对于String这样的对象来说。</p>
<p>hashCode和equals之间由这样的关系的原因和java.util.HashMap这一类集合类的实现方式有关。支撑HashMap的数据结构是某种类型的表，例如数组或列表。hashCode值的作用是判定表中要使用的索引值。由于hashCode返回的是int，所以返回的值有可能为负数，也有可能返回比表的大小要大的值。任何HashMap的实现都会对这个值进行操作，从而得到合法的表索引值。</p>
<p>和equals一样，Object类的hashCode方法也是通过内存位置生成hashCode值的。这意味着两个在不同位置但是逻辑上相等的实例返回的hashCode会不同。</p>
<p>下面的代码中Set实现的行为不符合预期。代码中的集合不知道如何正确的比较Person对象，因为Person对象没有实现equals。只要实现一个比较name字符串和age整数的equals方法即可修复这个实现的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.hashCode()*age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrongSetBehavior</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Person&gt; people=<span class="keyword">new</span> HashSet&lt; &gt;();</span><br><span class="line">    <span class="keyword">final</span> Person person1=<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    <span class="keyword">final</span> person person2=<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">final</span> Person person3=<span class="keyword">new</span> Person(<span class="string">&quot;Charlie&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> person1Added=people.add(person1);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> person2Added=people.add(person2);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> person3Added=people.add(person3);</span><br><span class="line">    </span><br><span class="line">    assertTure(person1Added &amp;&amp; person2Added &amp;&amp; person3Added);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逻辑上等于person1</span></span><br><span class="line">    <span class="keyword">final</span> Person person1Again=<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    <span class="comment">//应该返回false，因为Alice已经在集合中了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> person1AgainAdded=people.add(person1Again);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//但是会返回ture，因为没有实现equals方法</span></span><br><span class="line">    assertTrue(person1AgainAdded);</span><br><span class="line">    assertEquals(<span class="number">4</span>,people.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据hashCode和equals方法之间的关系，有这样一条重要规则：如果要重写hashCode或equals方法，那么这两个方法都必须重写。事实上，像IntelliJ和Eclipse这样的IDE不允许在生成一个方法的情况下不生成另一个方法。</p>
<p>尽管相等的对象必须返回同一个hashCode，但是反过来不一定是这样。</p>
<p>如下为一个合法的hashCode()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这种写法是不可取的。因为HashMap（以及HashMap支撑的HashSet）通过hashCode方法计算保存对象引用的表索引。如果不相等的对象具有相同的hashCode值，那么这些对象都会通过LinkedList数据结构保存在同一个索引。</p>
<p>如果所有要保存在一个HashMap中的对象都会返回同一个hashCode，那么这个HashMap的性能就降级为链表的性能了：所有的对象都保存在HashMap中的同一个槽中。寻找值的操作需要遍历所有对象的值，一个一个地判定是否相等。</p>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p><strong><em><u>==数组在Java中是怎样表示的？==</u></em></strong></p>
<p>关于Java中的数组，要记住的一件最重要的事情就是：数组也是对象。数组可以像对象一样的操作。可以对数组调用toString()(尽管没什么用)，还可以以多态方式使用数组，例如将数组保存在一个Object容器中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arraysAsbjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; mapping=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    mapping.put(<span class="string">&quot;key&quot;</span>,<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    assertTure(mapping.get(<span class="string">&quot;key&quot;</span>) <span class="keyword">instanceof</span> (<span class="keyword">int</span>[]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于数组就是对象，所以数组是通过引用传递的，因此通过数组的引用就可以以某种方式修改数组。</p>
<p>下面的代码演示了数组的修改，这种方式可能会引起很大的困惑，因为数组可能会在代码的其他位置被修改，甚至可能在不同的线程中被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrayReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] myArray=<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] arrayReference2=myArray</span><br><span class="line">        </span><br><span class="line">        arrayReference2[<span class="number">5</span>]=<span class="number">99</span>;</span><br><span class="line">    </span><br><span class="line">    assertFalse(myArray[<span class="number">5</span>]==<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String的使用"><a href="#String的使用" class="headerlink" title="String的使用"></a>String的使用</h2><p><strong><em><u>==String在内存中是怎样保存的？==</u></em></strong></p>
<p>使用Java的一大好处就是所有的库实现都可以查看。下面代码表示Java1.7中String的实现看上去不会太出格。String表示的值通过char数组来保存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">	<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,</span></span><br><span class="line"><span class="class">	<span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String类在Java语言中的地位非常核心，使用非常广泛，因此尽管String只是Java库中定义的一个类，但是JVM和编译器都会在特定的情形下以特别的方式处理String。因此几乎将String看成是原始类型。</p>
<p>在创建String字面量时，没必要，也最好不要调用new。在编译时，String字面量——–即一对引号之间所有字符——–都会被创建为String。</p>
<p>下面代码中的两个String是一样的，在任何运行的程序中都可以当成同一个值来处理。首先看helloString的构建：当编译器看到字符序列“，H，e，…..,!,”时，编译器就知道要创建一个String字面量，其值为双引号之间的字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringCreation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String helloString1=<span class="keyword">new</span> String(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">		String helloString2=<span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		assertEquals(helloString1, helloString2);</span><br></pre></td></tr></table></figure>

<p>当编译器处理helloString1时，看到引号之间的字符，也会为这个值创建一个String对象。由于这个String字面量出现在一个构造函数的调用中，所以这个对象也被传入构造函数。后面会提到，由于String是不可变的，所以构造函数会对传入的值做一份拷贝。构造函数String(char[]）会对这个数组做一次完整拷贝。当试图向String构造函数中传入一个String字面量时，大部分IDE都会生成一条警告———这种操作是没有必要的。</p>
<p><strong><em><u>==可不可以修改一个String的值？==</u></em></strong></p>
<p>查看String支持的方法，可以发现所以看上去修改String的方法实际上都会返回一个String实例。</p>
<p>尽管下面的代码并不显得非常意外，但是确实能体现String的一个最重要的行为：String的值永远不会变化。String是不可变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringChanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> String greeting=<span class="string">&quot;Good Morning, Dave&quot;</span>;</span><br><span class="line">	<span class="keyword">final</span> String subString=greeting.substring(<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	assertTrue(subString.equals(<span class="string">&quot;Good&quot;</span>));</span><br><span class="line">	assertFalse(greeting.equals(subString));</span><br><span class="line">       assertTrue(greeting.equals(<span class="string">&quot;Good Morning, Dave&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码表面，看上去“修改”String的方法，例如上述代码中使用的substring，以及其他的如replace和split方法，返回的都是新的字符串拷贝，新字符串的内容做了相应的修改。</p>
<p>实例表示的值永远不会发生变化，有了这个关于不可变性的认识可以有很多好处。不可变对象都是线程安全的：这种对象可以用于很多个并发线程中，每一个线程都知道对象的值永远都不会变化，因此不需要使用锁机制或复杂的线程同步机制。</p>
<p>String并不是Java标准库中唯一的不可变类。所有的数值类，例如Integer，Double，Character和BigInteger都是不可变的。</p>
<p><strong><em><u>==什么是驻留（interning）？==</u></em></strong></p>
<p>继续之前对String字面量和不可变性的讨论，JVM在运行时会对字面量有特别的关照。当JVM加载类时，会将所有的字面量保存在一个常量池中。如果出现了重复的String字面量，那么重复字面量可以通过池中已经存在的相同常量来引用。这种技术称为String驻留（interning）。</p>
<p>显然，由于这个池中的常量可以被JVM中运行时任意类引用，同时发生的引用可能会轻易达到成千上百，因此String的不可变性变得非常有必要。</p>
<p>String字面量并不是String驻留池的唯一用户，任何String实例都可以通过intern()</p>
<p>方法添加到这个池中。如果要对来自一个文件或网络连接的大量数据进行解析，而且这些数据可能包含大量的重复内容，那么可以使用String驻留技术，这是一种政党的使用场景。想象一下有一个巨大的银行对账单，其中包含很多来自某一方的借贷交易或借记交易，或者包含了类似于多次购买同一个产品的重复相似交易。如果这些条目在读入时都驻留化了，那么在JVM中只有一个占用内存的实例。String类的equals方法也会检查两个被比较对象的实例引用的是否是内存中的同一个位置，因此，String相等时的比较会非常快。</p>
<p>注意intern()方法也是有代价的：尽管这些String不是保存在堆上，但是也需要保存在其他地方，即PermGen空间。</p>
<p>如果对intern()的滥用导致常量池中存在很多条目，例如数百万条目，那么每一个条目的查询开销也会对应用程序的运行性能造成影响。</p>
<p>String常量池是享元模式的一种实现，在Java库中还有其他地方也使用了类似这样的模式。例如，下面的代码展示了对于值在-128和127之间的Integer对象来说，方法Integer.valueOf(String)会返回同一个Integer对象实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">intEquality</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//为了让String出现在不同的内存位置中，</span></span><br><span class="line">		<span class="comment">//显式地调用new String</span></span><br><span class="line">		<span class="keyword">final</span> Integer int1=Integer.valueOf(<span class="keyword">new</span> String(<span class="string">&quot;100&quot;</span>));</span><br><span class="line">		<span class="keyword">final</span> Integer int2=Integer.valueOf(<span class="keyword">new</span> String(<span class="string">&quot;100&quot;</span>));</span><br><span class="line">		</span><br><span class="line">		assertTrue(int1==int2);</span><br></pre></td></tr></table></figure>

<p>通过相等性判断，这段代码确保了这些对象引用的是内存中的同一个实例（JUnit 的Assert.assertSame()也能实现同样的判定，但是这里结合==使用assertTrue()看上去更清楚）。</p>
<h2 id="理解泛型"><a href="#理解泛型" class="headerlink" title="理解泛型"></a>理解泛型</h2><p><strong><em><u>==解释如何结合泛型使用Collections API。==</u></em></strong></p>
<p>泛型(generic)也称为模板化类型(parameterized type)。结合泛型使用Collections类时，编译器就知道约束集合只允许包含特定类型的对象。</p>
<p>下面的代码是完全合法的：代码将String添加到一个List实例，然后通过这个实例访问String。get方法返回一个Object，因为List是多态的。List类能够处理任意类型的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List authors;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Author</span><span class="params">(<span class="keyword">final</span> String name)</span></span></span><br><span class="line"><span class="function">		</span>&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAuthors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		authors=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		</span><br><span class="line">		authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;Stephen Hawking&quot;</span>));</span><br><span class="line">		authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;Edgar Allan Poe&quot;</span>));</span><br><span class="line">		authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;William Shakespeare&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authorListAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">final</span> Author author=(Author) authors.get(<span class="number">2</span>);</span><br><span class="line">			assertEquals(<span class="string">&quot;William Shakespeare&quot;</span>, author.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		 </span><br></pre></td></tr></table></figure>

<p>由于列表没有被约束为只允许包含Author类的实例，所以下面的代码也是合法的，这反映了一个开发者可能犯的简单错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List authors;</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useStrings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		authors.add(<span class="string">&quot;J.K.Rowling&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> String authorAsString=(String)authors.get(authors.size()-<span class="number">1</span>);</span><br><span class="line">		assertEquals(<span class="string">&quot;J.K.Rowling&quot;</span>, authorAsString);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码对列表中的实例没有任何约束。从上述代码可以看出几个问题。是否可以绝对的肯定列表中只有这些类型的对象？如果不是的话，运行时会抛出ClassCastException异常。而类型转换本身就是很糟糕的代码。</p>
<p>通过使用泛型，运行时可能会发生的异常会转变为编译错误。在开发生命周期中，编译错误会被更早的发现，因此也可以更快的修复错误，并且得到更简洁的代码。如下代码展示了泛型的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Author&gt; authors;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Author</span><span class="params">(<span class="keyword">final</span> String name)</span></span></span><br><span class="line"><span class="function">   </span>&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAuthors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   authors=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">   authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;Stephen Hawking&quot;</span>));</span><br><span class="line">   authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;Edger Allan Poe&quot;</span>));</span><br><span class="line">   authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;William Shakespeare&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">  	</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authorListAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Author author=authors.get(<span class="number">2</span>);</span><br><span class="line">   assertEquals(<span class="string">&quot;William Shakespeare&quot;</span>, author.getName());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中没有为访问数据而使用的类型转换，读起来更加自然：“从作者列表中获得第3位作者”。</p>
<p>authors实例被限定为只能接受类型为Author的对象。另一个测试useStrings现在根本就通不过编译。编译器会注意到这个错误。将这个测试从使用String修改为使用Author就可以轻松修复这个错误。</p>
<p>集合API中的所有类都使用了泛型。根据现在已经看到的例子，List接口及其实现接受一个类型参数。Set也是一样。不出所料，Map接受两个类型参数，一个表示键的类型，另一个表示值的类型。</p>
<p>泛型类型还可以嵌套。比如说可以这样合法地定义一个Map： HashMap&lt;Integer,List<String>&gt;,这表示一个将Integer类型的键映射到String类型的List的HashMap。</p>
<p><strong><em><u>==修改给定的栈API，使其使用泛型==</u></em></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List values;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		values=<span class="keyword">new</span> LinkedList();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">		values.add(<span class="number">0</span>,object);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(values.size()==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> values.remove(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈的实现在面试中是一个非常常见的问题。栈支持的操作集比较小，通常包括push和pop，有时候还可能包括peek。栈通常是使用Java集合API实现的，不需要其他的库。花一点时间确认自己是否真正理解了为什么这里使用的是LinkedList——–是不是也能使用ArrayList？两者之间有何区别？</p>
<p>针对这个给定的实现，这是一个全功能的栈，不过还不支持使用泛型。这个实现会遇到前一个问题中讨论的所有问题。</p>
<p>为了将这个类逐渐迁移至使用泛型，可以在编译器的指导下完成。首先，必须将Stack类声明为接受被参数化的类型：</p>
<p><code>public class GenericStack&lt;E&gt;&#123;</code></p>
<p><code>values.add(0,element);</code></p>
<p><code>&#125;</code></p>
<p>将values修改为List<E>还会在Stack的构造函数中产生一个编译器警告。在创建values LinkedList时，也需要参数化：</p>
<p><code>public GenericStack() &#123;</code></p>
<p><code>values=new LinkedList&lt;E&gt;();</code></p>
<p><code>&#125;</code></p>
<p>编译器注意不到的一个变化是pop方法的变化。pop方法的最后一行values.remove(0)现在返回的是类型为E的值。而目前，这个方法返回的是Object。编译器没有理由对此报错或给出警告，因为Object是所有类的超类，而不论E表示什么具体类型。对此，可以将返回类型修改为E：</p>
<p><code>public E pop() &#123;</code></p>
<p><code>if (values.size()==0) &#123;</code></p>
<p><code>return null;</code></p>
<p><code>&#125;</code></p>
<p><code>return values.remove(0);</code></p>
<p><code>&#125;</code></p>
<p><strong><em><u>==类型变体（type variance)对泛型有什么影响？==</u></em></strong></p>
<p>假定有以下类层次关系：</p>
<p><code>class A &#123;&#125;</code></p>
<p><code>class B extends A &#123;&#125;</code></p>
<p>B是A的一个子类。但是List<B>不是List<A>的一个子类。这种变体称为类型协变(covariance),Java的泛型系统无法对此进行建模。</p>
<p>在使用泛型类型时，有时候可能需要接受一个类的子类作为参数。例如针对前一个问题中的GenericStack类，假设有一个工具方法通过A的List创建一个新的GenericStack：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GenericStack&lt;A&gt; <span class="title">pushAllA</span><span class="params">(<span class="keyword">final</span> List&lt;A&gt; listOfA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> GenericStack&lt;A&gt; stack=<span class="keyword">new</span> GenericStack&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(A a: listOfA) &#123;</span><br><span class="line">        stack.push(a);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这段代码可以正常编译，而取对于A的List来说运行结果完全符合预期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> usePushAllA &#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;A&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> GenericStack&lt;A&gt; genericStack=pushAllA(list);</span><br><span class="line">    </span><br><span class="line">    	assertNotNull(genericStack.pop());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果试图向B添加元素，则无法通过编译:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usePushAllAWithBs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;B&gt; listOfBs=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        listOfBs.add(<span class="keyword">new</span> B());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> GenericStack&lt;A&gt; genericStack = pushAllA(listOfBs);</span><br><span class="line">    </span><br><span class="line">    assertNotNull(genricStack.pop());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管B是A的子类，但是List<B>并不是List<A>的子类。pushAllA的方法签名应该修改为显式地允许类型A，以及A的任何子类：</p>
<p><code>public static GenericStack&lt;A&gt; pushAllA(final List&lt;? extends A&gt; listOfA)&#123;</code></p>
<p>代码中的问好称为通配符（wildcard），目的是告诉编译器这里允许A的扩展类的任何实例。</p>
<p><strong><em><u>==具体化（reified）是什么意思？==</u></em></strong></p>
<p>本质上说，具体化的意思就是在运行时生效。Java的泛型类型是没有具体化的。意思就是说编译器检查实现代码使用泛型参数是否正确时使用的所有类型信息都不是.class文件中定义的类型信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRefiedExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericTypesCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        strings.add(<span class="string">&quot;Die Hard 4.0&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;Terminator 3&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;Under Siege 2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(Stirngs.get(<span class="number">2</span>) <span class="keyword">instanceof</span> String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过JAD（一款Java反编译器）对上述代码生成的类文件进行反编译，得到代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRefiedExample</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericTypesCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList arraylist = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arraylist.add(<span class="string">&quot;Die Hard 4.0&quot;</span>);</span><br><span class="line">        arraylist.add(<span class="string">&quot;Terminator 3&quot;</span>);</span><br><span class="line">        arraylist.add(<span class="string">&quot;Under Siege 2&quot;</span>);</span><br><span class="line">        System.out.println(arraylist.get(<span class="number">2</span>) <span class="keyword">instanceof</span> String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的类型信息都丢了，这意味着，如果从一个编译后得到的类文件反编译得到这样的代码，那么必须假定这段代码一定服从编译时使用的泛型参数信息。</p>
<p>从这个例子可以看出，很容易构造出这样的程序：其中使用了一个带有某个泛型类型的List，但是动态加载的实例却是不同的类型。</p>
<p>如果没有提供构造函数，编译器会生成一个默认的构造函数。所有的类都必须至少有一个构造函数。</p>
<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p><em>==<u>原始类型的访问可能 抛出NullPointerException异常吗？</u>==</em></p>
<p>这个问题的答案是不可能的，但实际上好像会有这样的现象。以下面的代码为例，有几点需要注意的地方。当给intObject赋值42时，实际上是在将原始类型值42赋值给一个对象。这种行为本来是不合法的，而且在Java5之前，这样确实会产生编译错误。然而现在的编译器会使用一种称为自动装箱（autoboxing）的技术。编译器知道int类型对应的引用类型是Integer，因此这种行为是合法的。如果编译器不能感知这两种类型之间的关系（Java5之前这样），那么如果需要一个对Integer对象的引用，就需要自己手工完成：既可以使用new Integer(42),也可以使用效率更高的Integer.valueOf(42)。</p>
<p>Integer.valueOf(42)效率更高的原因是小值会被缓存。此缓存模式称为享元模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">primitiveNullPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Integer intObject = <span class="number">42</span>;</span><br><span class="line">		<span class="keyword">assert</span>(intObject == <span class="number">42</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> newIntValue = methodWhichMayReturnNull(intObject);</span><br><span class="line">			fail(<span class="string">&quot;Assignment of null to primitive should throw NPE&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">			<span class="comment">//误操作，测试成功</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Integer <span class="title">methodWhichMayReturnNull</span><span class="params">(Integer intValue)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动装箱和装箱的区别</p>
</blockquote>
<blockquote>
<p>Java5引入了自动装箱的概念。自动装箱指的是自动地将原始类型转换为对应的引用类型，例如boolean，转换为Boolean，以及int转换为Integer。</p>
<p>在Java5之前，这种操作必须手工完成，即装箱操作。为了将int转换为Integer，必须构造一个(new Integer(42))，或使用工厂模式（Integer.valueOf(42))。</p>
</blockquote>
<p>将装箱的引用类型，例如Float， Integer 和 Boolean 转换为对应原始类型的 float, int 和 boolean 的过程称为拆箱。同样，这也是编译器提供的一个操作。不过此时应该警惕的问题是，只要要使用引用类型，就必须注意引用为null的情况，对于装箱类型来说就是如此。当编译器将Integer转换为int时，编译器会假定被转换的值不为null，因此如果被转换的类型为null，那么会立即抛出NullPointerException异常。try代码块中的第一行代码将类型为Integer的方法返回值赋给原始类型int。在这个例子中总是返回null，因此运行这一行时一定会抛出NullPointerException异常。因为无法将null值赋给原始类型。当尝试调用或修复相关问题时，特别是不很清楚哪里发生了装箱和拆箱操作时，这样的行为可能会导致挫败感和混乱感。</p>
<p>原始类型不能用于泛型类型定义，也就是说不能有类似List<int>这样的类型。在使用泛型的情况下必须使用引用类型。</p>
<h2 id="使用注记"><a href="#使用注记" class="headerlink" title="使用注记"></a>使用注记</h2><p><strong><em><u>==给出一个使用注记（annotation）的例子。==</u></em></strong></p>
<p>注记是在Java5中引入的，JUnit库从JUnit4开始充分利用了这些注记。</p>
<p>下面的代码展示了JUnit4之前测试是如何工作的。编写测试套件时，测试的命名采用特定的约定，此外测试运行之前和之后要运行的步骤也采用特定的命名约定。JUnit运行器会通过反射技术查看TestCase子类编译得到的测试。如果找到了public void setUp()这样的方法签名，那么每一个测试运行之前都会运行这个方法。所有返回类型为void 的公共方法以及名字以test开头的方法都会被当成测试来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit3Example</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> myInt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myInt = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">textMyIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">42</span>, myInt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myInt = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>text前缀的输入错误，或setUp以及tearDown的拼写错误都可能导致测试无法进行，而且不会有任何错误提示。更糟糕的是，测试可能会失败。</p>
<p>随着注记的引入，这种脆弱的命名约定可以被抛弃了，取而代之的是通过注记来标注相应的方法，因此允许测试使用表达性更好的定义。下面的代码展示了同一个测试使用注记之后的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit4Example</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> myInt;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Before</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assignIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			myInt = <span class="number">42</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkIntValueIsCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Assert.assertEquals(<span class="number">42</span>, myInt);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@After</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsetIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			myInt = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>即使你没有任何和JUnit相关的经验，也很容易理解使用注记对于测试来说是很好的：方法可以有更好的名字，而且方法可以有多个注记。一个方法可以既有@Before又有@After注记也是可行的，这样可以避免代码重复。</p>
<p><strong><em>==@Override注记有什么用？==</em></strong></p>
<p>@Override 注记表示一个非常有用的编译时检查。这条指令告诉编译器，有一个父类的方法要被重写。如果在父类中没有匹配的方法签名，那么表示出现了一个错误，编译应该停止。</p>
<p>一般来说，这是避免在重写方法时产生错误的绝好方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GENERIC VEHICLE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CAR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，getrame()方法貌似被重写为返回描述性更强的内容，但是以下代码实际上会打印出GENERIC VEHICLE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car c = <span class="keyword">new</span> Car();</span><br><span class="line">System.out.println(c.getName());</span><br></pre></td></tr></table></figure>

<p>这是因为Car类中有一个拼写错误：类中的方法是 getname() 而不是 getName() 。Java中所有的标识符都是大小写敏感的。这种bug 的追查特别痛苦。</p>
<p>如果在重写 getName() 方法时添加标记@Override，那么编译器就会在这里标出一个错误。这个错误很快就可以得到修复。</p>
<p>和王超一样，你因该使用专业水准的IDE，并且尽可能利用IDE提供的帮助。IntelliJ和Eclipse都提供了重写方法的向导对话框，这样就可以准确地选择你想要重写的方法。这些向导会自动添加@Override 注记，因此想错也错不了。</p>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>当面试官在看示例代码时，不论代码是来自面试题还是候选人的示例代码（肯是从Github或类似的网站上摘取的代码），他们都会考察代码的质量，从final关键字的使用到变量命名的约定都会被考察到。IDE对命名约定的支持是非常棒的，而且几乎没有什么理由要拒绝这些约定。IDE有助于代码更容易被同事和评审人接受。</p>
<p>==类==</p>
<p>类总是以大写字母开头，并且采用骆驼命名法（CamelCase):</p>
<ul>
<li>Boolean</li>
<li>AbstractJUnit4SpringContextTests</li>
<li>StringBuilder</li>
</ul>
<p>==变量和方法==</p>
<p>变量和方法总是以小写字母开头，并且也采用骆驼命名法：</p>
<ul>
<li>int myInteger = 56;</li>
<li>public String toString();</li>
</ul>
<p>==常量==</p>
<p>static final 实例变量永远不会变化，因此也称为常量。常量的命名约定是全部大写，单词之间通过下划线隔开：</p>
<ul>
<li>public static final int HTTP_OK = 200;</li>
<li>private static final String EXPECTED_TEST_RESPONSE = “YES”;</li>
</ul>
<p>争论比较多的是如何骆驼命名法对缩写正确地命名。接受度高的是第一个字母大写，其他字母小写，例如 HttpURLConnection 在一个类中使用了两种风格！</p>
<p>从作者他的角度来看，大写第一个字母的方法更容易接受，因为这样可以更清楚地看到缩写词在哪里结束以及下一个单词在哪里开始。现在很多IDE，可以仅通过输入骆驼命名法中每一个单词首字母来搜索类。</p>
<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p><strong>==<em><u>描述Java异常层次结构中的核心类。</u></em>==</strong></p>
<p>下图展示了异常层次结构，并且给每一个类型都附了例子。</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201113201227.png" alt="image-20201113200626814"></p>
<p>所有可以被抛出的类都是对Throwable的扩展。Throwable有两个直接子类：Error和Exception。按照惯例，在必要时抛出并解决Exception一般是开发人员的职责。而Error则是无法恢复的问题，例如OutOfMemoryError和NoClassDefFoundError。</p>
<p>异常本身的定义分为两类：一个异常既可以指运行时异常（runtime exception），也可以指检查异常（checked exception）。运行时异常由RuntimeException的子类表示。检查异常则时任何其他的异常。</p>
<p>如果一个方法（或构造函数）可能会抛出检查异常，那么在方法定义中应该显式地定义这个异常。这个方法所有的调用者都必须准备好处理这个异常，处理的方法既可以是将异常抛出给调用自己的方法，也可以是将方法调用包装在一个try/catch/finally代码块中，并且根据具体情况处理异常。</p>
<p><strong><em>==运行时异常和检查时异常孰优孰劣？==</em></strong></p>
<p>在使用检查异常时，必须明确告诉用户那些地方可能会出错。在编写可能会抛出检查异常的方法时，要尽可能的声明。像public String getHostName() throws Exception 这样的方法定义给用户关于哪里会出错的信息太少。如果这样定义：public String getHostName() throws UnknownHostException, 那么用户就应该了解哪里可能会出错，而且可以对方法的工作方式有更深入的理解。</p>
<p>关于运行时异常，在方法上定义异常，重抛异常以及使用try/catch/finally 代码块都是可选的。作为一般性的原则，RuntimeException异常是任何一位心细的开发者都应该避免的异常，例如访问数组的索引超出了数组大小的异常 ArrayIndexOutBoundsException 或对 null 引用调用方法的异常 NullPointerException。</p>
<p>在定义API并决定是使用运行时异常还是使用检查异常时，作者他的建议是优先使用运行时异常，并且通过任何形式的文档明确地告诉调用这个方法的客户可能会抛出什么异常。使用try/catch/finally 代码块会添加大量模式化的代码，即使只是最简单的方法调用，因此未来代码的维护会非常困难。比如说观察一下对JDBC的正规调用，就经常会发现在try/catch/finally代码块中嵌套了try/catch/finally代码块。一些现代的编程语言，例如Scala，已经摒弃了异常检查异常，只支持运行时异常。</p>
<p>==<strong><em>什么是异常链(exception chaining)?</em></strong>==</p>
<p>当捕捉一个异常以处理一个错误的情形时，完全可以用重新抛出这个异常，甚至还可以抛出一个不同类型的异常。</p>
<p>需要重新抛出异常的原因包括将一个检查异常转换为一个运行时异常，以及对异常执行一些日志操作然后再重新抛出这个异常。当抛出一个之前已经捕捉到的异常时，建议抛出一个新的异常，并且在这个新的异常中添加一个引用。这种技术称为异常链。</p>
<p>在catch代码块中抛出一个新的异常采用的也是一样的思想。在新异常的构造函数中传入一个指向老异常的引用。</p>
<p>这样做的原因是：在对没有处理的异常进行调试时，这些异常链非常有价值。栈跟踪记录可以在应用程序控制台中输出所有这些信息。</p>
<p>在栈跟踪记录中可以通过”caused by” 行找到这些信息。 这里可以找到被包装前或重新抛出前的原始异常。</p>
<p>下面演示如何创建异常链。catch代码块中的异常实例将其引用传递给IllegalStateException 的构造函数，从而链接到了一个新的IllegalStateException 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exceptions</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">addNumbers</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(first &gt; <span class="number">42</span>)  &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;First parameter must be small&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> first + second;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionChaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				total = addNumbers(<span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;total = &quot;</span> + total);</span><br><span class="line">			&#125;<span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to add munbers together&quot;</span>,e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>Java标准库中的所有异常都可以在构造函数中接受一个 throwable 实例。如果你要创建新的 Exception 类，请一定要遵循这个原则。</p>
<p>当这个测试（不可否认这是一个人为编造的例子）运行时，演示了 IllegalStateException异常确实是因为传入AddNumbers方法的第一个参数的值太高而引起的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalException: Unable to add numbers together</span><br><span class="line">	at com.wiley.acinginterview.chapter08.Exception.exceptionChaining</span><br><span class="line">		(Exceptionns.java:<span class="number">23</span>)</span><br><span class="line">    at sun.reflet.NativeMethodAccessorImpl.invoke()(Native Method)</span><br><span class="line">    ...</span><br><span class="line">    &lt;Exeption truncated&gt;</span><br><span class="line">    ...</span><br><span class="line">    	at sun.reflect.NativeMethodAccessorImpl.invoke</span><br><span class="line">    		(NativeMethodAccessorImpl.java:<span class="number">39</span>)</span><br><span class="line">    	at com.intellij.rt.execution.application.Appain.main</span><br><span class="line">    		(AppMain.java:<span class="number">120</span>)</span><br><span class="line">    Caused by: java.lang.IllegalArgumentException: First parameter must be small</span><br><span class="line">        at com.wiley.acinginterview.chapter08.Exceptions.addNumbers</span><br><span class="line">        	(Exceptions.java:<span class="number">9</span>)</span><br><span class="line">        at com.wiley.cinginterview.chapter08.Exceptions.exceptionChaining</span><br><span class="line">        ...<span class="number">26</span> more</span><br></pre></td></tr></table></figure>

<p>如果异常没有串联在一起，而且try代码块中的代码规模大得多，那么要找到最初的异常是从哪里抛出的会是一件非常耗时的体力活。</p>
<p>如果发现catch代码块中抛出了一个异常，而且没有链接到原始异常，那么请在这里添加一个指向原始异常的引用。以后你会庆幸自己这么做了！</p>
<p>​            <strong><em><u>==try-with-resources语句是什么？==</u></em></strong></p>
<p>Java7 为try/catch/finally 语句引入了一种语法糖。如果一个类实现了 AutoCloseable 接口，那么不需要担心资源关闭的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demonstrateResourceHandling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(<span class="keyword">final</span> FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;/tmp/dataFile&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>];</span><br><span class="line">			reader.read(buffer);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// ...处理异常</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在引入 try-with-resources 语句之前，reader实例应该显示地关闭，而如果关闭操作失败的话，关闭本身也会抛出异常或不确定的行为。在更糟糕的情况下，甚至可能会忘记关闭。</p>
<p>AutoCloseable 接口指定了一个方法 close(), 这个方法会在try 代码块之后调用， 就好像在代码块的finally 部分调用一样。</p>
<h2 id="使用Java标准库"><a href="#使用Java标准库" class="headerlink" title="使用Java标准库"></a>使用Java标准库</h2><p>Java标准库中的API 涵盖了很多领域，从数据库访问到优化的搜索和排序算法，从并发相关的API到两个用户界面框架， 无所不包。</p>
<p><strong><em><u>==为什么私有字段还需要通过标记 final 设置为不可变？==</u></em></strong></p>
<p>如果有一个 final 类没有可访问的setter 方法， 而且所有的字段都是私有的，那么你可能会认为这个类是不可变的， 如下面的代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BookRecord</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    ptivate String bookTitle;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookRecord</span><span class="params">(String author, String bookTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>,bookTitle = bookTitle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookTitle</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> bookTIitle;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，事实并非想象的这样。通过反射 API（Reflection API）依然可以操纵这些字段，反射机制有能力访问并修改所有字段，不论这些字段的可见性如何。final 修饰符可以告诉JVM这些字段绝对不允许修改。尽管这种允许访问外界标记不可访问状态的方法看上去有点猥琐，但却是存在一些合法的情形是这么做的。 在 Spring 框架的控制翻转（Inversion of Control)容器中， 当容器在运行时被初始化时会对带有@Autowired注记的私有字段进行设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mutateBookRecordState</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException,</span></span><br><span class="line"><span class="function">											   IllegalAccessException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> BookRecord record = <span class="keyword">new</span> BookRecord(<span class="string">&quot;Suzanne Collins&quot;</span>,</span><br><span class="line">												 <span class="string">&quot;The Hunger Games&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Field authorField = record.getClass().getDeclaredField(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">		author.setAccessible(ture);</span><br><span class="line">		author.set(record,<span class="string">&quot;Catching Fire&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		assertEquals(<span class="string">&quot;Catching Fire&quot;</span>, record.getAuthor());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>除非编写自己的框架 一般来说很少需要修改私有字段的值，特别是那些自己没有控制权的类。</p>
<p><strong><u><em>所有的集合API类都是从哪些类继承而来的？</em></u></strong></p>
<p>大致来说，集合框架包含三大类定义：各种Set 各种list以及各种Map。 还有一个专门的Queue接口，这个接口提供了一些关于队列元素的简单操作，包括添加，删除和查看。ArrayList类既是一个List又是一个Queue。Java Collections框架包含在java.util包中。所有的单元素集合都实现了Collection接口，该接口指定了一些针对整体的方法，例如删除所有元素的 clear()方法和统计集合中有多少条目的size()方法。映射的实现没有实现Collection接口。Java倾向于将映射和集合区分开。当然，Collection 和 Map 还是有关联的：Map接口包含的 entrySet(), keySet() 和values() 方法都以 Collection 的形式返回 Map 中的不同数据。</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201114155039.png" alt="image-20201114154852490"></p>
<p><strong><u><em>什么是LinkedHashMap？</em></u></strong></p>
<p>LinkedHashMap的名字看上去令人困惑———到底是不是HashMap呢？ 又是在何种意义上的链接(linked)？</p>
<p>LinkedHashMap 具有 HashMap 的所有特性——–即根据键索引快速查找元素——–但同时还能保留进入映射数据结构条目的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLinkedHashmapProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> LinkedHashMap&lt;Integer,String&gt; linkedHashMap = <span class="keyword">new</span></span><br><span class="line">				LinkedHashMap&lt;&gt;();</span><br><span class="line">		linkedHashMap.put(<span class="number">10</span>, <span class="string">&quot;ten&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">30</span>, <span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">40</span>, <span class="string">&quot;forty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">50</span>, <span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//工作方式和map一样</span></span><br><span class="line">		assertEquals(<span class="string">&quot;fifty&quot;</span>, linkedHashMap.get(<span class="number">50</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遵循插入的顺序</span></span><br><span class="line">		<span class="keyword">final</span> Iterator&lt;Integer&gt; keyInterator = linkedHashMap.keySet().</span><br><span class="line">				iterator();</span><br><span class="line">		</span><br><span class="line">		assertEquals(<span class="string">&quot;ten&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;twenty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;thirty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;forty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;fifty&quot;</span>,linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//而HashMap却没有这样的特性</span></span><br><span class="line">		<span class="keyword">final</span> HashMap&lt;Integer, String&gt; regularHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		regularHashMap.put(<span class="number">10</span>, <span class="string">&quot;ten&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">30</span>, <span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">40</span>, <span class="string">&quot;forty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">40</span>, <span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> ArrayList hashMapValues = <span class="keyword">new</span> ArrayList&lt;&gt;(regularHashMap.values());</span><br><span class="line">		<span class="keyword">final</span> ArrayList linkedHashMapValues = <span class="keyword">new</span> ArrayList&lt;&gt;(linkedHashMap.values());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//列表中仍然有相同的值，但是顺序不同</span></span><br><span class="line">		assertFalse(linkedHashMapValues.equals(hashMapValues));</span><br><span class="line">	&#125;<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLinkedHashmapProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> LinkedHashMap&lt;Integer,String&gt; linkedHashMap = <span class="keyword">new</span></span><br><span class="line">				LinkedHashMap&lt;&gt;();</span><br><span class="line">		linkedHashMap.put(<span class="number">10</span>, <span class="string">&quot;ten&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">30</span>, <span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">40</span>, <span class="string">&quot;forty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">50</span>, <span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//工作方式和map一样</span></span><br><span class="line">		assertEquals(<span class="string">&quot;fifty&quot;</span>, linkedHashMap.get(<span class="number">50</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遵循插入的顺序</span></span><br><span class="line">		<span class="keyword">final</span> Iterator&lt;Integer&gt; keyInterator = linkedHashMap.keySet().</span><br><span class="line">				iterator();</span><br><span class="line">		</span><br><span class="line">		assertEquals(<span class="string">&quot;ten&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;twenty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;thirty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;forty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;fifty&quot;</span>,linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//而HashMap却没有这样的特性</span></span><br><span class="line">		<span class="keyword">final</span> HashMap&lt;Integer, String&gt; regularHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		regularHashMap.put(<span class="number">10</span>, <span class="string">&quot;ten&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">30</span>, <span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">40</span>, <span class="string">&quot;forty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">40</span>, <span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> ArrayList hashMapValues = <span class="keyword">new</span> ArrayList&lt;&gt;(regularHashMap.values());</span><br><span class="line">		<span class="keyword">final</span> ArrayList linkedHashMapValues = <span class="keyword">new</span> ArrayList&lt;&gt;(linkedHashMap.values());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//列表中仍然有相同的值，但是顺序不同</span></span><br><span class="line">		assertFalse(linkedHashMapValues.equals(hashMapValues));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u><em>既然已经有了Hashtable，为什么还要引入HashMap？</em></u></strong></p>
<p>Collections框架和集合类的接口（Collection， Map 和List等）最早出现在Java 1.2版本zhong。而Hashtable类等效于列表的Vector在最初的版本的Java中就存在了。这些类在编写时还没有考虑到框架的问题。当引入Collection框架时，Hashtable被重写以符合Collection接口。</p>
<p>Hashtable类是synchronized，尽管对并行任务很有效，但对单线程任务会有显著的性能开销。而HashMap 不是 synchronized，因此开发者可以自行将这个类的使用调整为满足任何特定的并发需求。建议在并行环境中需要严肃使用Map接口的地方使用ConsurrentHashMap类(Java 5引入)。</p>
<h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><p>Java8可以定义接口的默认实现。如果默认实现足够用了，那么接口的实现者可以不提供自己的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Java8Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alpha</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> beta <span class="keyword">default</span> &#123;<span class="keyword">return</span> <span class="number">6</span>; &#125;;</span><br><span class="line">    String omega <span class="keyword">final</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Cannot override&quot;</span>; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了默认实现之外，接口中还可以包含final实现。现在Java的接口工作方式和抽象类非常接近。</p>
<p>过去几年出现了不少能编译到JVM上执行的语言。其中有一些语言（例如， Scala和Groovy支持lambda表达式，在这些语言中，函数被当成一等公民，函数可以当成变量量传入其他函数或方法。lambda表达式表示的是匿名函数，例子如下，lambda表达式可以用于任何要求只有一个方法的接口的情形。lambda表达式可以内联在代码中，替代完整的接口实现。注意代码中新出现的语法：参数， 箭头， 然后是方法体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ints = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ints.add(<span class="number">1</span>);</span><br><span class="line">    ints.add(<span class="number">2</span>);</span><br><span class="line">    ints.add(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; newInts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ints.forEach(i -&gt; &#123; newInts.add(i+<span class="number">10</span>); &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ints.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">assert</span> ints.size() == newInts.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span> ints.size() == newInts.size();</span><br><span class="line">    System.out.println(<span class="string">&quot;Validated&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List接口，或者更准确地说是 Iterable接口， 添加了一个新的方法：forEach。如果接口不支持默认实现，那么这个方法需要添加到Iterable接口是所有实现中——–不仅仅是Java标准库中的实现需要，所有的第三方代码都需要！</p>
<p>forEach 方法接受的一个参数是新的Consumer 接口的实例。 这个接口有一个方法accept， 这个方法的返回类型为 void，并且接受一个参数。由于只有一个方法，因此这里可以使用lambda 表达式。 当forEach 被调用时，传入这个方法的参数是 Consumer的一个实例，而这个方法的参数类型和列表中的参数类型相同。当遍历列表时，每一个元素都被传递给Consumer的实现。由于Consumer返回的是void， 所以 lambda 表达式不能向调用的方法返回任何值。在上面的代码中，lambda表达式接受每一个元素作为参数， 加上10，然后将得到的值放到新的List没有通过任何途径修改； 检查新的List中保存了正确的值； 检查两个List中都没有多余的元素。</p>

    </div>

    

    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a target="_blank" rel="noopener" href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/11/09/Java%E5%9F%BA%E7%A1%80/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/11/06/%E9%9B%86%E5%90%88/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/11/03/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/10/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">我的第一篇博客文章</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://telegram.org/">
                            <span class="footer-icon-container">
                                <i class="fa fa-telegram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>