<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="wsh549"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="wsh549"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>wsh549</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="wsh549" type="application/atom+xml">
</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">wsh549</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/11/15/Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B4%E5%90%88/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-11-15</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="UJava应用程序和数据库的整合"><a href="#UJava应用程序和数据库的整合" class="headerlink" title="UJava应用程序和数据库的整合"></a>UJava应用程序和数据库的整合</h1><p>面向对象语言能够用丰富的方式对真实的世界进行建模。。关系数据库将数据持久化在表格中，而表格通常是一种更平坦的数据结构，对同样的表达能力具有局限性。</p>
<p>本章讨论如何连接和使用数据库，以及如何将Java数据类型持久化到数据库中。本章所有示例都使用MySQL数据库，包括通过MySQL控制台访问(用mysql&gt;提示符表示)，以及通过Java的数据库接口访问。</p>
<h2 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h2><p>SQL是一种抽象的声明式语言，用于在关系数据库中执行查询和数据操作。SQL是一种标准，和具体的数据库实现无关。如今基本上所有正在使用的成熟的关系数据库产品都支持SQL。</p>
<p><strong><u><em>如何通过SQL从关系数据库检索数据？</em></u></strong></p>
<p>关系数据库中的数据保存在很多表中，而表是由行和列组成的。每一个表通常都描述了一个逻辑的实体（entity）,也可以称为关系(relation), 例如一个人，一个地址或一个库存清单项。数据库中的每一行称为一条记录(record)， 每一条记录都可以被唯一地标识。唯一标识符称为主键(primary key). </p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115145904.png" alt="image-20201115145855605"></p>
<p>从表中可以看出，每一条记录都可以通过employee_number列标识。这个表只保存了和员工相关的信息。</p>
<p>SQL是一种用于解释和操作关系数据库数据的灵活语言，提供了一种对问题域有意义的表达式形式。如果要查询某张表，应该使用SQL SELECT语句：</p>
<p><code>SELECT name,office_location_id FROM emplyees;</code></p>
<p>这条查询语句返回的是employees表中的所有行，但是只包含name和 office_location_id列：</p>
<p><code>mysql&gt; SELECT name,office_location_id FROM emplyees;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115150855.png" alt="image-20201115150828278"></p>
<blockquote>
<p>SQL语句和大小写敏感性</p>
<p>通常来说，SQL语句是大小写敏感的。大小写敏感的不仅包括语句的关键字(例如SELECT, FROM 和WHERE等)，还包括查询语句中的对象， 例如列表和表名等。</p>
<p>一个常用的约定是SQL关键字用大写，对象名称用小写。这种约定可以帮助代码的读者根据大小写变化将查询语句分解为不同的逻辑块。</p>
</blockquote>
<p>有时候需要检索某一指定的行或某一些特定的行。为此，需要在SELECT语句中加上WHERE 子句。这个子句会对一个布尔表达式求值而且会针对每一行进行求值。如果表达式对某一行求值为真，那么这一行就会被包含在结果集中：</p>
<p><code>mysql&gt; SELECT name,office_location_id FROM emplyees WHERE employee_number&gt;2;</code><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115153627.png" alt="image-20201115153626879"></p>
<p>注意这个例子中的WHERE子句对并不包含在结果集中的一个列进行求值，也就是说在查询语句中可以访问任意列，即使被访问的列不在最终的结果集中。</p>
<p>如果要在查询中返回所有的列，那么可以使用通配符*表示所有的列：</p>
<p><code>mysql&gt; SELECT * FROM emplyees WHERE employee_number = 1;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115154120.png" alt="image-20201115154120113"></p>
<p>如果在表中添加，删除，或者修改了列，此查询都可以正常工作，只不过返回的结果不同。假设这个表隶属于一个公司的大型数据库，那么可以想象这个数据库中还有其他表示不同实体的表，例如表示公司所有办公地点的信息以及每个人工作地点的信息，甚至还有各个管理层结构的信息。数据库的迷人之处和威力就在于这些关系之间的交互。</p>
<p>下面的表定义了这个公司数据库中的另外一个，名为office_locations 的表。</p>
<p><code> CREATE TABLE office_location (office_location_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,location_name VARCHAR(20),address VARCHAR(20),lease_expiry_date DATE); Query OK, 0 rows affected (2.16 sec)</code></p>
<p><code>mysql&gt; INSERT INTO office_location VALUES(1,&#39;New York&#39;,&#39;Union Plaza&#39;,NULL),(2,&#39;Paris&#39;,&#39;Revolution Place&#39;,NULL),(3,&#39;London&#39;,&#39;Piccadilly Square&#39;,&#39;2014-05-30&#39;); Query OK, 3 rows affected (0.12 sec)</code></p>
<p><code>mysql&gt; SELECT * FROM office_location;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115160107.png" alt="image-20201115160106939"></p>
<p>尽管这个表中的信息从逻辑上和employees表是分离的，但是这两个表之间肯定是有关系的。对这两个表检索可以得到以下结果：</p>
<p><code>mysql&gt; select emplyees.name,office_location.location_name     -&gt; from emplyees,office_location;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115160840.png" alt="image-20201115160840797"></p>
<p>这些数据并不是我们想要的。为什么会得到这样的结果呢？因为数据库并不知道应该怎样将这些行组织在一起，因此只能从employees表中取出每一行，然后将每一行和office_locations 表中的每一行进行配对。如果需要更有意义的结果，必须告诉数据库怎样组织这些表的关系，代码清单如下：</p>
<blockquote>
<p>两个表的连接</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT*</span><br><span class="line">	FROM emplyees</span><br><span class="line">	JOIN office_location</span><br><span class="line">	ON emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115161821.png" alt="image-20201115161820981"></p>
<p>这条语句可以返回我们所需要的数据集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select emplyees.name,office_location.location_name</span><br><span class="line">from emplyees</span><br><span class="line">join office_location</span><br><span class="line">on emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115162232.png" alt="image-20201115162232315"></p>
<p>两个或者多个表查询称为连接(join)。执行连接还可以使用另一种语法，可以在SQL语句的FROM部分列出所有的表，然后再WHERE子句中连接这些表即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM emplyees,office_location</span><br><span class="line">WHERE emplyees.office_location_id &#x3D; office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115162857.png" alt="image-20201115162857038"></p>
<p>尽管两者看上去区别并不大，但是前一种连接查询（称为ANSI join）对于关系的区分更为清晰。如果上述查询中有WHRER子句，那么这个子句中的每一个部分都会用于数据行的过滤，而不会用于定义表之间的关系。</p>
<p>emplyees表的offic_location_id列引用了office_locations表中同名的列。这一列称为外键(forign key),表示引用其他表中列的列。在数据库中设置外键关系是可选的操作，然而这么做可以优化查询功能，因为数据库会知道针对这个列的连接操作和过程操作是预料之中的。</p>
<p>定义外键还可以强制保证引用的完整性：在emplyees表中，office_location_id的取值不可以超出office_locations表中对应的取值范围。反过来，在emplyees表中存在的office_location_id不可以在office_locationa表中删除，每一个员工都必须有合法的办公地点。</p>
<p>如果在定义表时忽略了外键关系，那么两个表之间就没有引用完整性：引用的列中可以包含被连接的表中不存在的数据。不过有时候者正是你所需要的。</p>
<p>==<strong><em>什么时内连接？什么时外连接？</em></strong>==</p>
<p>默认情况下，两个表中满足匹配条件的行都会包含在连接内。此外还可以指定连接操作中的一个或两个表中的所有行都包含在连接中，用NULL填补缺失的匹配。</p>
<p>office_location 表中包含一些在employees表中没有引用的数据行。这肯是因为这家公司目前还有空的办公地点。上面的代码中没有出现这个办公地点。</p>
<p>在查询的JOIN字句中，如果指定的是LEFT OUTER JOIN, 那么结果中会包含来自查询中左侧的所有行，在右侧没有匹配的地方则填上NULL。RIGHT OUTER JOIN则是相反的操作。</p>
<blockquote>
<p>右外连接查询</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">	FROM emplyees</span><br><span class="line">	RIGHT OUTER JOIN office_location</span><br><span class="line">	ON emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115170013.png" alt="image-20201115170003352"></p>
<p>此查询为每一个location_name都返回了一条结果，不论其对应的位置有没有雇员在办公：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT emplyees.name,office_location.location_name</span><br><span class="line">FROM emplyees</span><br><span class="line">RIGHT OUTER JOIN office_location</span><br><span class="line">ON emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115170852.png" alt="image-20201115170852534"></p>
<p>左外连接和右外连接还可以同时进行，在两个表中对于不存在的项都填入NULL，使用的语法是FULL OUTER JOIN。在employees表和office_locations表之间不能执行这种连接，因为office_location_id是一个外键关系：不可能有员工工作在数据库中不存在的地点。</p>
<p><strong><u><em>SQL能对数据库中的数据进行分析吗？</em></u></strong></p>
<p>SQL包含了很多可以对列执行计算的函数。如果你有使用关系式数据库的经验，那么你可能使用过计算表中行数的COUNT函数：</p>
<p><code>SELECT COUNT(*) from enployees;</code></p>
<p>此查询返回的是employees表中行的数目。</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115175516.png" alt="image-20201115175515996"></p>
<p>下表定义了一个员工工资表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table salaries (employee_number int not null primary key auto_increment,annual_salary VARCHAR(20),last_update_date VARCHAR(20));</span><br><span class="line">mysql&gt; INSERT INTO salaries values(1,20000,2013-06-29),(2,12000,2013-06-29),(3,6000,2012-06-10),(4,6000,2013-06-16),(5,12000,2013-05-26);</span><br><span class="line">mysql&gt; select * from salaries;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115191021.png" alt="image-20201115191021437"></p>
<p>SUM函数计算某一指定列的所有行的总和。财务部门可以通过对annual_salary应用这个函数计算年工资总开销。</p>
<blockquote>
<p>计算一列的总和</p>
</blockquote>
<p><code>mysql&gt; select sum(annual_salary) from salaries;</code></p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115191855.png" alt="image-20201115191855084"></p>
<p>还可以首先将一些具有同样特征的行分组，然后再利用这些函数对某个类进行计算操作。例如，如果想要查看公司中每一个职位的平均工资，需要使用AVG函数，并且根据员工的职位进行分组。</p>
<blockquote>
<p>使用GROUP BY 子句</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select e.title,avg(s.annual_salary)</span><br><span class="line">   from emplyees e</span><br><span class="line">   join salaries s</span><br><span class="line">   on e.employee_number&#x3D;s.employee_number</span><br><span class="line">   group by e.title;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115192715.png" alt="image-20201115192715794"></p>
<p>在查询中包含了title列之后，需要指定GROUP BY子句，否则数据库不知道如何为不同的职位组织数据。如果没有这个子句，则产生的数据是无意义的：计算了年度工资栏的平均值，然后将原表中的第一行数据（即CEO)用作title列。</p>
<blockquote>
<p>注意：上述示例中使用的表和列都包含一些很长很啰嗦的名字。上面的代码清单使用表定别名，别名的作用是可以在查询过程中对表重命名，在这个例子中将表重命名为更短的名字。</p>
<p>如果要将一个表和自己连接，那么需要为每一个表创建一个别名，否则在连接或使用WHERE子句时数据库不知道引用的是哪一个实例。</p>
</blockquote>
<p><u><strong><em>怎样将数据持久化到数据库中？</em></strong></u></p>
<p>到现在为止，我们只是通过SQL查询表中已有的数据。通过INSERT语句可以向表中插入数据，通过UPDATE语句可以修改已有的行，通过DELETE语句可以删除行。</p>
<p>INSERT语句包含要插入某张表的数据：</p>
<p><code>INSERT INTO emplyees VALUES （1，&#39;Bob Smith&#39;,&#39;CEO&#39;,&#39;1,Pine Drive&#39;,CURDATE(),1);</code></p>
<p>插入多行数据可以使用同样的方法，提供的是用逗号隔开的表示行的元素的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO emplyees VALUES</span><br><span class="line">(2,&quot;Alice Smith&quot;,&quot;CEO&quot;,&quot;1,Pine Drive&quot;,CURDATE(),1),</span><br><span class="line">(3,&quot;Cassandra Williams&quot;,&quot;Developer&quot;,&quot;336,Cedar Court&quot;,CURDATE(),2),</span><br><span class="line">(4,&quot;Dominic Taylor&quot;,&quot;Receptionist&quot;,&quot;74A,High Road&quot;,CURDATE(),2),</span><br><span class="line">(5,&quot;Eric Twinge&quot;,&quot;Developer&quot;,&quot;29,Acacia Avenue&quot;,CURDATE(),1);</span><br></pre></td></tr></table></figure>

<p>还可以插入行的部分内容，前提是没有提供列用NULL代替不会影响约束条件，或者是有默认值。在语句中要给出具体要更新的列：</p>
<p><code>INSERT INTO emplyees(employee_number,name,title,office_location_id)</code></p>
<p><code>VALUES(6,&quot;Frank Roberts&quot;,&quot;Developer&quot;,&quot;2&quot;);</code></p>
<p>更新数据时，需要指定具体要更新的列以及新的值，还可以提供表示要更新的行的匹配条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE emplyees</span><br><span class="line">set home_address&#x3D;&quot;37,King Steet&quot;</span><br><span class="line">where employee_number&#x3D;6;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115201145.png" alt="image-20201115201144928"></p>
<p>如果通过主键匹配行，那么根据定义，只更新一行数据，因为主键唯一标识一行。此外，表也会针对主键建立索引，因此数据库应该可以瞬时定位要跟滚动行。</p>
<p>如果在UPDATE语句中提供了WHERE子句，那么更新操作会针对所有行进行。</p>
<p>删除行也可以通过WHERE子句来指定要删除的行：</p>
<p>DELETE FROM emplyees WHERE name=”Frank Roberts”;</p>
<p>一定要小心！如果忽略了WHERE子句，那么所有的行都会被删除；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from emplyees;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115202042.png" alt="image-20201115202041953"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from emplyees;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115202255.png" alt="image-20201115202255794"></p>
<p>如果要修改表中的数据，总是应该使用事务。这样的话，在提交事务之前，数据库允许你ROLLBACK(回滚)任何错误。</p>
<p><strong><u><em>什么是视图？</em></u></strong></p>
<p>为了方便起见，我们可以将一个常用的查询或连接设置为一个“虚拟表”，这个虚拟表称为视图（view)。对于需要在数据库控制台直接运行多个查询的开发者或者运维人员来说，视图往往可以提供帮助。</p>
<p>如果经常需要通过一条查询来查找员工及其工作地点，那么通过下面的语句可以创建一个反映这些信息的视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW employees_and_locations AS</span><br><span class="line">SELECT employee_number,name,location_name,address</span><br><span class="line">FROM emplyees</span><br><span class="line">JOIN office_location</span><br><span class="line">ON emplyees.office_location_id&#x3D;office_location.office_location_id;</span><br></pre></td></tr></table></figure>

<p>然后就可以向普通表一样查询这个视图了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees_and_location;</span><br></pre></td></tr></table></figure>

<p>还可以从一个视图中删除数据行。当然，引用完整性的一般性原则在这里也要遵循。此外还可以添加行。如果视图定义中的列有缺失，那么会使用NULL值。如果对应的列不允许使用NULL值，那么这一行数据就不能插入到视图中。</p>
<p>一般情形下，不建议从视图中删除数据。试图太轻量级了，很容易修改其定义，因此当某个列定义从视图中移除时很容易连带地插入NULL值。</p>
<p><strong><em>==DDL和DML是什么?==</em></strong></p>
<p>到目前为止，我们讨论的例子仅仅和数据的操纵有关。SQL还可以用于创建，删除和修改表。数据操纵语言（Data Manipulation Language,DML)通过SELECT,INSERT,UPDATE和DELETE关键字操纵数据。数据定义语言(Data Definition Language,DDL)的用途则是创建和操纵表的结构。</p>
<p>创建表的语句是CREATE TABLE语句。这个语句包含了列的列表以及每一列的数据类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE meeting_rooms (</span><br><span class="line">    -&gt; meeting_room_id   INT,</span><br><span class="line">    -&gt; office_location_id  INT,</span><br><span class="line">    -&gt; meeting_room_name VARCHAR(100)</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure>

<p>这条语句会创建一个带有3个列的表，其中两个列的类型为INT，另外一列的类型为VARCHAR(100),即最长为100个字符的字符串。注意，不同数据中的合法数据类型可能会有所不同。你需要在数据库供应商提供的最新文档中查看哪些类型是合法的。</p>
<p>在这个表中尽管有一个名为office_location_id的列，但是没有指向office_locations表的引用，在此列中没有针对可接受数据的引用完整性规则。</p>
<p>如你所想，DDL不只可以创建表，还可以修改表的定义，例如添加一个列：</p>
<p><code>ALTER TABLE meeting_rooms ADD COLUMN telephone_extension VARCHAR(100);</code></p>
<p>对meeting_rooms表执行SELECT操作时会显示这一列，就好像这一列一直存在一样。如果这个表已经有数据了，那么这一列就会为空，因此显示一个NULL值。在ALTER TABLE语句中可以指定默认值。</p>
<p>要删除(drop)一列，可以运行下列语句：</p>
<p><code>ALTER TABLE meeting_rooms</code></p>
<p><code>ADD FOREIGN KEY (office_location_id)</code></p>
<p><code>REFERENCES office_locations(office_locaton_id);</code></p>
<p>创建了这个约束之后，只有合法的office_location_id值才能插入meeting_rooms表中的那一列。如果在这一列中已经有数据不满足约束条件，那么这条语句会被拒绝。</p>
<p>还可以增加其他任何类型的约束。例如定义一个不允许NULL值的列，或定义一个列只允许接受某个范围内的整数值。</p>
<p><strong><u><em>如何加速低效的查询？</em></u></strong></p>
<p>看一下之前的employees表，记录会按顺序保存在磁盘上，很可能是按照employee_number列的顺序保存的，因此101号员工的数据会保存在100号员工之后，以此类推。</p>
<p>在大部分情况下，通过这种方式保存数据是意义不是太大，因为很少有情况需要根据员工工号的顺序获得员工列表。</p>
<p>针对这些数据的一个可能的查询是查找所有在某个特定办公地点工作的员工：</p>
<p><code>SELECT * FROM employees WHERE office_location_id=2;</code></p>
<p>此查询需要按顺序检查每一行是否满足WHERE子句。如果表中有数千行数据时，这条查询会耗费一阵子时间，特别是在没有任何一行于条件匹配时。</p>
<p>通过给这一列增加索引，数据库可以直接查询这一列，得到指向行位置的直接引用。</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201115212423.png" alt="image-20201115212423252"></p>
<p>这张表还会额外保存office_location_id 的分组信息，数据库会通过这些信息查找办公地点对应的数据行。这里需要付出的代价是需要更多的磁盘空间来保存这些索引</p>
<blockquote>
<p>创建索引</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index office_loc_idx on employees(office_location_id);</span><br></pre></td></tr></table></figure>

<p>创建了索引之后，向employees表插入数据时还会在索引中创建一个条目，可能会导致插入数据耗费的时间更长。带来的好处是查询更快了，特别是在表增长到数千行的规模时。</p>
<p><strong><em>==如果SQL不能满足需求怎么办？==</em></strong></p>
<p>存储过程(stored procedure)提供的功能比SQL 提供的简单创建，读取，更新和删除功能更为强大。在存储过程中可以执行更多的过程式步骤。</p>
<p>下面给出一个需要创建存贮过程的例子：为超过一年没有加薪的员工加薪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE annual_salary_raise (</span><br><span class="line">   IN percent INT,</span><br><span class="line">   OUT total_updated INT</span><br><span class="line">   )</span><br><span class="line">   BEGIN</span><br><span class="line">   SELECT COUNT(*)</span><br><span class="line">   INTO total_updated</span><br><span class="line">   FROM salaries</span><br><span class="line">   WHERE last_update_date&gt;DATE_SUB(CURDATE(),INTERVAL 1 YEAR);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE salaries</span><br><span class="line">SET annual_salary&#x3D;annual_salary*((100+percent)&#x2F;100),</span><br><span class="line">    last_update_date&#x3D;CURDATE()</span><br><span class="line">WHERE last_update_date&gt;DATE_SUB(CURDATE(),INTERVAL 1 YEAR);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>这个存储过程接受两个参数：一个IN参数，表示工资增长的百分数：一个OUT参数，可以看成是存储过程的返回值。这里传入一个语柄，存储过程通过语柄设置值，然后再运行完存储过程之后就可以通过语柄读取值。在这个例子中，OUT参数保存的是更新的行数。IN参数和OUT参数的数目可以根据自己的需求随意指定。</p>
<p>SELECT 语句的形式也不相同，将COUNT函数的结果填入total_updated OUT参数。如果SELECT语句返回0行或多余1 行数据，则这条查询会失败。</p>
<p>这个存储过程对那些已经超出一年没有更新的行应用百分比更新。MySQL提供了一个用于操纵DATE数据类型的DATE_SUB函数——-这个例子中，这个函数计算的是CURDATE(表示今天的日期)之前一年的日期。这条更新语句还会将最后更新的日期设置为CURDATE，因此被更新的行在一年之内不会被更新。</p>
<blockquote>
<p>调用MySQL存储过程，实现4%的涨薪</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select curdate();</span><br><span class="line"></span><br><span class="line">mysql&gt;select * from salaries;</span><br><span class="line"></span><br><span class="line">mysql&gt;call annual_salary_raise(4,@updated_count);</span><br><span class="line"></span><br><span class="line">mysql&gt;select * from salaries;</span><br><span class="line"></span><br><span class="line">mysql&gt;select @updated_count;</span><br></pre></td></tr></table></figure>

<p>存储过程特别适合于批量操作一系列语句，通过某种定制的方式操纵数据，上述存储过程就是这样一个例子。另一种用法是在触发器（trigger）中使用。当某个特定的数据库事件发生时，例如删除或更新一行数据时，可以配置在动作发生之前或之后运行一个存储过程，也可以用一个存储过程替代相应的动作。</p>
<p>触发器的一个实际用法是记录数据库事件。当一个敏感的表（例如记录员工工资的财务表）被更新时，可以设置一个存储过程，在向这张表插入数据之前和之后向一张辅助的审计表中插入数据，如果事后有任何分歧时可以在审计表中有据可查。</p>
<p><strong><em>==什么是事务？==</em></strong></p>
<p>上上个代码所展示的存储过程存在一个问题，即OUT参数中返回的更新的行数可能和实际更新的行数不一致。这个存储过程执行了两个操作：首先，计算要更新的行的数目，然后执行实际的更新操作。如果有一个客户在运行annual_salary_raise存储过程的同时，另一个客户对salaries表进行更新并且更新的数据会被存储过程中的更新语句影响，那么第二个客户的更新操作可能会发生在第一个客户通过SELECT统计行数之后，第一个客户通过UPDATE更新薪资数据之前。</p>
<p>通过将这个过程事务化，就可以避免以上竞争条件的发生。</p>
<p>不论在什么领域(数据库领域或者其他领域)中，事务(transaction)都要满足4个条件，这个条件统称为ACID：</p>
<ul>
<li><p><strong>原子性</strong>(Atomic)——–事务中的内容要么全部以一个 整体完成，要么完全没有做。不可能在数据库中看到事务只执行了一半的状态。</p>
</li>
<li><p><strong>一致性</strong>(Consistent)——–执行完事务之后，数据库满足作用域的所有要求。例如，当有两方进行支付时，从一方借记的金额应该匹配另一方存入的金额。</p>
</li>
<li><p><strong>隔离性</strong>(Isolated)———每一个并行运行的事务其行为看上去都应该好像只有这一个事务在数据库中运行。</p>
</li>
<li><p><strong>持久性</strong>(Durable)———事务一旦被提交之后，就永久地提交了。数据库中任何后续的修改，例如更新或崩溃，都不会对已提交的事务造成影响。</p>
</li>
<li><p>为了将上上个代码中存储过程持久化，必须通过START TRANSACTION语句开始一个事务，并最终通过COMMIT语句成功提交事务。</p>
<blockquote>
<p>使用事务</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE annual_salary_raise_transactional (</span><br><span class="line">	IN percent INT,</span><br><span class="line">	OUT total_updated INT</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	START TRANSACTION;</span><br><span class="line">	SELECT COUNT(*)</span><br><span class="line">	...</span><br><span class="line">	...&lt;参见上上个代码&gt;</span><br><span class="line">	...</span><br><span class="line">	WHERE last_update_date&lt;DATE_SUB(CURDATE(),INTERVAL 1 YEAR);</span><br><span class="line">	COMMIT;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>当事务在运行时，其他连接在尝试更新salaries表时都会被阻塞，直到这个事务完成执行。</p>
<p>在运行存储过程的过程中，如果发现数据库处在不一致的状态，或者存储过程中有一些条件没有满足，可以自己中止事 务。通过ROLLBACK（回滚）语句种植事务。</p>
<p>回滚通常是由数据库日志管理的，回滚时反向执行从事务开始时的所有日志。其他运行的事务可能依赖于被回滚的事务的结果，在这种情况下，这些依赖的事务也会被回滚。</p>
<p><strong><em>==什么是NoSQL==</em></strong></p>
<p>NoSQL是一个覆盖性的术语，指的是所有不严格遵循关系式数据库模型的数据库。这些数据库处理的通常是非范式化的数据，通常以键-值对，全文档或图的形式保存数据，目的是让数据的检索速度尽可能地块，从而使得应用程序的相应能力更强。在操纵海量数据时，例如TB级的数据甚至PB级的数据时，对相应能力有特别的要求。</p>
<p>在NoSQL领域，没有和SQL对应的访问标准，因为每一个数据库都以自己的方式存储数据。NoSQL的一个缺点就是一旦开始使用某个NoSQL数据库产品，那么就会被绑定到某个特定的厂商，因为迁移的过程需要在不同数据库的模型之间映射，因此会有特异性而且非常费劲。</p>
<p>下面是一些流行的NoSQL数据库产品：</p>
<ul>
<li>MognoDB——-数据以JSON对象的形式保存，而且类似的对象之间不一定有相同的字段。</li>
<li>Cassandra———数据保存在列族(column family)中。和表类似，但是不要求所有的行有相同的列。</li>
<li>Memcached———分布式键-值存储缓存。</li>
<li>Redis———集群化的持久键-值存储。</li>
</ul>
<h2 id="JDBC-整合Java和数据库"><a href="#JDBC-整合Java和数据库" class="headerlink" title="JDBC:整合Java和数据库"></a>JDBC:整合Java和数据库</h2><p><strong><em>==如何通过Java连接一个关系数据库？==</em></strong></p>
<p>Java Database Connectivity(JDBC)是构建在Java标准库连接机制。在使用JDBC连接数据库时，必须确保供应商的JDBC实现位于classpath中。在Java6之前，需要通过调用Class.forName(“<Vendor class>“)确保类加载器已经加载了数据库供应商为JDBC编写的驱动程序。现在这个过程已经被服务提供者机制自动化了，后者会在JAR的META-INF/services目录中提供一个查找项。</p>
<p>要创建连接，必须以URL的形式向JDBC提供相关的连接参数</p>
<blockquote>
<p>验证一个活跃的数据库连接</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectToDb</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Connection connection=DriverManager.getConnection(</span><br><span class="line">				<span class="string">&quot;jdbc:mysql://localhost:3306/company_db&quot;</span>,<span class="string">&quot;nm&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		assertFalse(connection.isClosed());</span><br><span class="line">		connection.close();</span><br><span class="line">		assertTrue(connection.isClosed());</span><br></pre></td></tr></table></figure>

<p>传递给DriverManager.getConnection的连接字符串传入了一个名为company_db的数据库的完整URL，这个数据库运行在本地服务器上，端口号默认的330户名为nm，密码为password。这个测试证实了可以创建连接，验证连接成功，然后关闭连接。</p>
<p><strong><em>==如何通过Java执行SQL查询？==</em></strong></p>
<p>建立好了数据库连接后，就可以通过执行SQL操作来检索和操纵数据。</p>
<blockquote>
<p>通过JDBC查询数据库，并将查询结果填入普通的Java类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retrieveRows</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Connection connection=DriverManager.getConnection(</span><br><span class="line">				<span class="string">&quot;jdbc:mysql://localhost:3306/company_db&quot;</span>,</span><br><span class="line">				<span class="string">&quot;nm&quot;</span>,</span><br><span class="line">				<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		<span class="keyword">final</span> java.sql.Statement stmt=connection.createStatement();</span><br><span class="line">		<span class="keyword">final</span> ResultSet rs=stmt.executeQuery(</span><br><span class="line">				<span class="string">&quot;select employee_number,name from employees&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Map&lt;Integer,String&gt; employeeMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> employeeNumber=rs.getInt(<span class="string">&quot;employee_number&quot;</span>);</span><br><span class="line">			<span class="keyword">final</span> String name=rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">			employeeMap.put(employeeNumber,name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Map&lt;Integer,String&gt; expectedMap=<span class="keyword">new</span> HashMap&lt;Integer,String&gt;()&#123;&#123;</span><br><span class="line">			put(<span class="number">1</span>,<span class="string">&quot;Bob Smith&quot;</span>);</span><br><span class="line">			put(<span class="number">2</span>,<span class="string">&quot;Alice Smith&quot;</span>);</span><br><span class="line">		&#125;&#125;;</span><br><span class="line">		</span><br><span class="line">		assertEquals(expectedMap,employeeMap);</span><br><span class="line">		</span><br><span class="line">		rs.close();</span><br><span class="line">		stmt.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>数据库连接提供了语句，语句运行查询，查询返回结果集。</p>
<p>ResultSet接口具有类似Iterator的访问方式。当ResultSet实例打开时，数据库有一个打开的游标(sursor),每一次调用next时都会将游标移动至下一行。这个方法返回一个Boolean值，如果返回false则表明该查询中没有更多的行。</p>
<p>每一个数据库厂商都提供了自己的JDBC类的实现，例如Statement，ResultSet和Connection类。因此，厂商应该自行提供从数据库数据类型到Java类型的映射。通常情况下，这都不会是大问题，因为大部分数据类型都有逻辑上等价的类型。在上述代码中，employee_number列是MySQL数据库中的Integer类型，因此对ResultSet调用getInt会将数据转换为Java的int类型。类似的，name列的类型是VARCHAR，它会被映射为一个String。</p>
<p>getXXX方法是被重载的方法，可以接受表示列名字符串作为参数，也可以接受表示列索引（从1开始）的int作为参数。</p>
<p><strong><em>==如何避免SQL注入攻击？==</em></strong></p>
<p>如果有某条查询需要反复运行，数据库可以协助完成查询准备，从而得到更快且更安全的查询。</p>
<p>使用查询参数（query parameter）可以让数据库编译查询，并对查询做好预处理然后只要提供参数就可以执行实际的查询。</p>
<blockquote>
<p>使用查询参数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryParameters</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> PreparedStatement pStmt=conn.prepareStatement(</span><br><span class="line">				<span class="string">&quot;insert into office_locations values (?,?,?,NULL)&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Map&lt;String,String&gt; locations=<span class="keyword">new</span> HashMap&lt;String,String&gt;()&#123;&#123;</span><br><span class="line">			put(<span class="string">&quot;London&quot;</span>,<span class="string">&quot;picadilly Square&quot;</span>);</span><br><span class="line">			put(<span class="string">&quot;New York&quot;</span>,<span class="string">&quot;Union Plaza&quot;</span>);</span><br><span class="line">			put(<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Revolution Place&quot;</span>);</span><br><span class="line">		&#125;&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (String location:locations.keySet()) &#123;</span><br><span class="line">			pStmt.setInt(<span class="number">1</span>,i);</span><br><span class="line">			pStmt.setString(<span class="number">2</span>,location);</span><br><span class="line">			pStmt.setString(<span class="number">3</span>,locations.get(location));</span><br><span class="line">			pStmt.execute();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		pStmt.close();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Statement stmt=conn.createStatement();</span><br><span class="line">		<span class="keyword">final</span> ResultSet rs=stmt.executeQuery(</span><br><span class="line">				<span class="string">&quot;select count(*) from office_locations&quot;</span>+</span><br><span class="line">		<span class="string">&quot;where location_name in(&#x27;London&#x27;,&#x27;New York&#x27;,&#x27;Paris&#x27;)&quot;</span>);</span><br><span class="line">		assertTure(rs.next());</span><br><span class="line">		assertEquals(<span class="number">3</span>,rs.getInt(<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		rs.close();</span><br><span class="line">		stmt.close();</span><br></pre></td></tr></table></figure>

<p>在上上一个代码中，查询是通过一个Statement对象执行的，但是在这个例子中，查询使用了一个PreparedStatement对象。创建一个PreparedStatement对象时，需要提供要运行的查询。不同的查询调用要使用的变量参数通过问号表示。</p>
<p>每一次要执行查询时，通过setXXX方法设置参数，指明查询中对应数据的类型。setXXX方法可以看成是ResultSet中对应的getXXX。同样，要注意这里的参数索引是从1而不是0开撕的。</p>
<p>使用带有特定数据类型的setXXX方法而不是将参数值硬编码为String可以实现一定程度的安全性，避免类似SQL注入这类攻击。</p>
<p>假设有一个Web服务要根据某一个列的ID显示数据库中的内容。这个网络服务是URL可能具有这样的形式：/showResults?id=3。这个网络服务可以简单地实现：接收解析后的查询参数，然后放在查询内直接传入数据库：</p>
<p><code>stmt.excuteQuery(&quot;select * from records where id=&quot;+queryParameters.get(&quot;id&quot;));</code></p>
<p>然而，恶意的用户可以将id参数的值替换为“3；DROP TABLE USERS;”。这样的话，以上代码就变成了两条查询：</p>
<p><code>SELECT * FROM records WHERE id=3;DROP TABLE users;</code></p>
<p>如果刚好不幸有一个名为users的表，那么这个表就会被删除。</p>
<p>然而如果这个查询是通过PreparedStatement执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> PreparedStatement ps=conn.prepareStatement(<span class="string">&quot;select * from records where id=?&quot;</span>);</span><br><span class="line">ps.setInt(<span class="number">1</span>,queryParameter.get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">ps.execute();</span><br></pre></td></tr></table></figure>

<p>当查询参数尝试将值设置为int’时，会在运行时抛出异常，因为恶意的字符串无法转换为int。</p>
<p>对于要进入数据库的输入，总是应该进行审查，而且只要条件允许，就尽量使用类型系统的帮助。</p>
<p><strong><em>==如何通过Java运行存储过程？==</em></strong></p>
<p>调用存储过程的方式和创建预处理语句的方式类似。通过下面的代码测试可以运行之前定义好的salary_update存储过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tes</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callStoresProc</span><span class="params">()</span> <span class="keyword">throws</span> SQLExcepton </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CallableStatement stmt =conn.prepareCall(<span class="string">&quot;&#123;call</span></span><br><span class="line"><span class="string">          annual_salary_raise(?,?)&#125;&quot;</span>);</span><br><span class="line">          stmt.setInt(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">          stmt.registerOutParameter(<span class="number">2</span>,Types.INTEGER);</span><br><span class="line">                                                   </span><br><span class="line">          stmt.execute();</span><br><span class="line">                                                   </span><br><span class="line">          <span class="keyword">int</span> updatedEmployees=stmt.getInt(<span class="number">2</span>);</span><br><span class="line">          assertEquals(<span class="number">1</span>,updateEmployees);                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个测试，假定在运行之前，数据库中只有一名员工满足涨薪条件。</p>
<p>对Connection对象调用prepareCall创建了一个CallableStatement对象。和Prepared-Statement对象类似，这里提供的是要在数据库中运行的语句，参数用问好表示。</p>
<p>所有不同的参数都要设置，同时设置数据类型。注意JDBC对输出参数是区别对待的。在语句执行结束之后收集这些输出参数的值。</p>
<p>调用存储过程的字符和具体的数据库相关：</p>
<p><code>&#123;call ANNUAL_SALARY_RAISE(?,?)&#125;</code></p>
<p>对于不同的厂商，这个字符串的结构会有所不同。要注意不同厂商发起调用的方式可能不同。例如，在Oracle PL/SQL中调用同名存储过程的字串如下所示：</p>
<p><code>conn.prepareCall(&quot;BEGIN ANNUAL_SALART_RAISE(?,?);END;&quot;);</code></p>
<p>这个调用是由BEGIN…END块而不是花括号包围。参数仍然通过问号来设置。</p>
<p><strong><em>==如何管理数据库连接==</em></strong></p>
<p>数据库的连接是一种源，而且创建连接的过程非常耗时，特别是连接需要在网络上协商建立时。创建数据库连接的过程往往比数据库操作本身还要耗时。</p>
<p>和线程池采用的方法类似，应用程序通常会管理一个数据库连接池。</p>
<p>有多个开源的库能够创建和管理连接池。这些库都遵循类似的方式：你要告诉库关于连接建立的细节，然后需要连接时，库就可以提供连接。库既可能创建一个新的连接，也可能会重用一个之前创建的连接，从而节省建立连接的时间。</p>
<p>C3P0是一个管理连接的开源项目。</p>
<blockquote>
<p>使用连接池</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionPools</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ComboPooledDataSource cpds=<span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/company_db&quot;</span>);</span><br><span class="line">cpds.setUser(<span class="string">&quot;nm&quot;</span>);</span><br><span class="line">cpds.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="keyword">final</span> Connection conn=cpds.getConnection();</span><br><span class="line">    <span class="keyword">final</span> Statement stmt=conn.createStatement();</span><br><span class="line">    <span class="keyword">final</span> ResultSet rs=stmt.executeQuery(</span><br><span class="line">    <span class="string">&quot;select count(*) from office_locations&quot;</span>+</span><br><span class="line">    <span class="string">&quot;where location_name in (&#x27;London&#x27;,&#x27;New York&#x27;,&#x27;Paris&#x27;)&quot;</span>);</span><br><span class="line">    assertTure(rs.next();</span><br><span class="line">              assertEquals(<span class="number">3</span>,rs.getInt(<span class="number">1</span>));</span><br><span class="line">               </span><br><span class="line">               DataSources.destroy(cpds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结束操作时不要关接池保存了对其创建的连接的引用，并且会周期性地通过一条简单的查询（例如SELECT 1 或者 SELECT 1 FROM DUAL 等，取决于具体的数据库）检查连接的健康状况。</p>
<p>使用连接池的好处是让应用程序更能应对数据库中止服务的情形。如果数据库崩溃或者重启，则所有的连接都会丢失，因此这些连接的所有引用都会失效，当应用程序对象对这些连接发出新请求时，连接池会对重启后的数据库创建新的连接，因为连接池会探测到旧的连接已不可用。</p>
<p><strong><em>==如何管理应用程序的数据库发布==</em></strong></p>
<p>发布Java应用程序时，通常是以单元的方式构建和发布应用程序，任何升级也是一个整体的形式进行升级，用升级版本替换现有的二进制版本。</p>
<p>而对于数据库来说并不总可以这么做，因为数据库中存储的数据必须在版本之间持久存在。</p>
<p>幸好，有一些可以和现有构建系统很好地整合的工具，这些工具可以管理和执行数据库部署和升级。</p>
<p>DBDeploy就是这样一种工具，这个工具可以直接和Maven或Ant协作。</p>
<p>每一次要在新版本中修改数据时，请在构建中添加一个带计数的文件，这个计数比上一次数据库变更文件的计数大1.DBDeploy在数据库中管理一个表，在一个名为changlog的表中记录运行脚本的列表。如果DBDeploy发现在changelog表中有任何没有被记录的文件，那么DBDeploy就会按照数字顺序执行这些脚本。</p>
<p>之后再次运行DBDeploy就会忽略这些文件，因为这些文件被记录为已经成功执行过。</p>
<h2 id="利用内存数据库进行测试"><a href="#利用内存数据库进行测试" class="headerlink" title="利用内存数据库进行测试"></a>利用内存数据库进行测试</h2><p><strong><em>==在开发数据库时能不能维护一个一致的环境？==</em></strong></p>
<p>在对一个需要访问数据库的应用程序进行活跃开发时，不容易将数据库维持在一个可维护的状态。有一种方法是使用一个和产品和集成环境中不同的数据库发行版：内存数据库。</p>
<p>顾名思义，内存数据库中的内容在JVM关闭时会丢失。因此特别适合使用测试数据，因为我们并不关心测试数据的持久化，而是更关心应用程序和数据库之间的交互是否符合预期。内存数据库也运行在本地机器，因此也不需要管理网络流量，数据库也不需要处理多个客户端的复杂连接问题。</p>
<p>一些开源的关系数据库提供了和SQL兼容的内存选项，H2就是一个这样的数据库。H2的设计很简单，不需要特别的代码启动数据库，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectToH2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Connection conn=DriverManager.getConnection(</span><br><span class="line">    <span class="string">&quot;jdbc:h2:mem:test;MODE=MySQL&quot;</span>,<span class="string">&quot;nm&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> Statement stmt=conn,createStatement();</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;create table teams(id INTEGER,name VARCHAR(100))&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;insert into teams values(1,&#x27;Red Team&#x27;)&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;insert into teams values(2,&#x27;Blue Team&#x27;)&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;insert into teams values(3,&#x27;Green Team&#x27;)&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> ResultSet rs=stmt.executeQuery(<span class="string">&quot;select count(*) from teams&quot;</span>);</span><br><span class="line">    assertTure(rs.next());</span><br><span class="line">    assertEquals(<span class="number">3</span>,getInt(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>H2通过连接字串jdbc:h2:mem:test就可以创建名为test的内存数据库，操作行为和其他JDBC连接是一样的。teams表只有在测试运行时才可用——-这个表没有保存在任何位置，因此这个测试每一次都可以运行成功。如果连接的是真实数据库，那么在运行任何针对teams表的测试之前，都要确定这个表的当前状态。username和password参数在这里不重要。</p>
<p>通过配置连接字串中设置可以自定义数据库的行为。连接字串jdbc:h2:mem;test;MODE=MySQL表示要求H2数据库理解MySQL的特性，即MySQL数据类型以及MySQL特有的SQL语言特性。</p>
<p>将内存数据库和DBDeploy结合使用，在测试集运行之前可以将DBDeploy脚本导入新创建的H2数据库，然后测试就可以像连接到普通MySQL数据库一样运行。</p>
<p>另外一种针对真实关系数据库测试的方式是打开的事务中运行，然后再测试结构（不论失败还是成功）时回滚事务。这种测试方式可能很高效，但是有风险。如果测试中会提交事务，那么就不能通过这种方式测试。此外，这种测试也依赖于真确的数据库状态。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/11/09/Java%E5%9F%BA%E7%A1%80/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-11-09</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>Java中的基本类型，例如boolean，int，和double等都成为原始类型（primitive type）JVM处理这些类型的方式和处理引用类型（reference type）的方式是不同的，引用类型也成为对象（object）。原始类型总会有一个值，绝不可能是null。</p>
<p>当定义一个int和long类型的变量时，编译器需要区分这两种类型。你需要做的是在long值后面添加L后缀。如果没有L，则表示值是int。L既可以大写也可以小写，但建议大写，因为这样可以帮助读代码的人轻松区分字母L和数字1.对于float和double值也是如此：float可以通过F定义，而double可以通过D定义。对于double来说，后缀是可选的，省略后缀表示double。</p>
<table>
<thead>
<tr>
<th align="center">原始类型</th>
<th align="center">大小（位）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16</td>
</tr>
</tbody></table>
<p>char是无符号的，也就是说，char的取值范围是0~65535，因为char可以表示Unicode值。</p>
<p>如果原始变量在定义时没有设置值，那么会使用一个默认值，boolean值的默认值是false。对于其他类型的值，默认是0的一种表示方式，例如int的默认值为0，float的默认值为0.0f。</p>
<p>必要时，编译器可以将值向上转换至恰当的类型，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value=Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">long</span> biggerValue=value+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>除了char类型的变量之外，编译器会自动使用更宽的类型表示变量，因为不会丢失任何精度，例如从int提升至long，以及从float提升至double。而反过来则不行。如果试图将一个long值赋给int，则必须对这个进行显示类型转换。显示类型转换告诉编译器这确实是我希望做的，而且不会在乎丢掉精度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> veryLargeNumber=Long.MAX_VAUE;</span><br><span class="line"><span class="keyword">int</span> fromLargeNumber=(<span class="keyword">int</span>) veryLargeNumber;</span><br></pre></td></tr></table></figure>

<p>==<em><u>为什么Integer.MIN_VALUE没有对应的正数？</u></em>==</p>
<p>short,int和long的二进制值在内存中存储时采用一种称为二进制补码（Two’s Complement)的形式。</p>
<table>
<thead>
<tr>
<th align="center">十进制</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0000 0000</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0000 0001</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0000 0010</td>
</tr>
</tbody></table>
<p>采用二进制补码表示法时，得到一个正数值对应的负数值的方法是执行二进制NOT操作然后加1.</p>
<p>因为取负值的操作需要两条指令。二进制补码的好处之一是只有一个零，即没有“负数</p>
<p>零”的概念。因而系统可以多存储一个负值。</p>
<table>
<thead>
<tr>
<th align="center">十进制</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-1</td>
<td align="center">1111 1111</td>
</tr>
<tr>
<td align="center">-1</td>
<td align="center">1111 1110</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">-127</td>
<td align="center">1000 0000</td>
</tr>
<tr>
<td align="center">-128</td>
<td align="center">1000 0000</td>
</tr>
</tbody></table>
<p>能存储的绝对值最大的负数的最高有效位是1，其他位都为0.对这个值取负数</p>
<p>操作：将所有的位取反得到（0111 1111），然后加1（得到1000 0000），最后得到的还是原始值，没有对应的正数！如果确实有必要使用这个值的正数，可以使用更宽的类型，例如long，或者更复杂的引用类型BigInteger，后者可以认为是没有上界的。</p>
<p>如果执行的计算产生的结果大于Inter.MAX_VALUE或小于Integer.MIN_VALUE,那么只有低32位会被保存，这种情况下会产生错误的结果。这种现象称为溢出（overflow）。</p>
<p>不能通过int类型表示Integer.MIN_VALUE的绝对值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">absoluteOfMostNegativeValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mostNegative=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> negated=Math.abs(mostNegative);</span><br><span class="line">    assertFalse(<span class="string">&quot;No positive equivalent of Integer.MIN_VALUE&quot;</span>,negated&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><p>==<strong><em><u>Java对象是什么?</u></em></strong>==</p>
<p>对象可以定义为 一组变量的集合和一组方法的集合，这组变量可以看成是整合在一起表示一个复杂的实体，而这组方法提供了和这个实体相关的操作。简而言之，对象是对状态和行为的封装。</p>
<p>除去原始类型之外，Java程序设计语言中的其他变量都死引用类型，更广泛的叫法是对象。对象和原始类型有很大区别，最重要的区别之一就是可以表达对象不存在的情况，即null。变量可以设置为null,方法也可以返回null。如果尝试对null对象调用方法，则会抛出NullPointerException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected=NullPointerException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expectedNullPointerExceptionToBeThrown</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stringLength=s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象都是引用类型，具体表示什么意思呢？在使用原始类型时，如果声明一个变量int i=42,这表示42这个值被赋给了内存中的一个位置。如果程序中后来又给另外一个变量赋予了变量i的当前值，例如 int j =i，那么内存中另一个位置被赋予了同一个值。后续对i的值的修改都不会改变j的值，反之亦然。</p>
<p>在Java中，类似new ArrayList（20)这样的语句在内存中申请一个区域保存数据。当这个创建的对象被赋予给一个变量时，例如List myList=new ArrayLIstanbul（20），那么表示myList指向了那个内存位置。从表面上看，这个行为和原始类型赋值的行为是一样的，但实际上是不一样的。如果多个变量被赋予了同一个对象（成为实例），那么这些变量指向的是同一个内存区域。通过一个变量对这个实例进行任何修改都会被其他变量看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objectMemoryAssignment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    list.add(<span class="string">&quot;entry in list1&quot;</span>);</span><br><span class="line">    assertTure(list1.size()==<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    List list2=list1;</span><br><span class="line">    list2.add(<span class="string">&quot;entry in list2&quot;</span>);</span><br><span class="line">    assertTrue(list1.size()==<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><u><strong>==final关键字对对象引用有什么作用？==</strong></u></em></p>
<p>final关键字的作用对于对象和对于原始类型是一样的。变量定义时设置变量的值，然后变量表示的内存位置存储的值不能变化。尽管对象引用不能变化，但是这个对象中的值可以变化，除非这些值本身都是final的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalReferenceChanges</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line">    <span class="comment">//i=43;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//list=new ArrayList(50);</span></span><br><span class="line">    assertEquals(<span class="number">0</span>,list.size());</span><br><span class="line">    </span><br><span class="line">    list.add(<span class="string">&quot;adding a new value into my list&quot;</span>);</span><br><span class="line">    assertEquals(<span class="number">1</span>,list.size());</span><br><span class="line">    </span><br><span class="line">    list.clear();</span><br><span class="line">    assertEquals(<span class="number">0</span>,list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<u><em>对象中的可见性修饰符（visibility modifier）有什么作用？</em></u>==</p>
<p>可见性修饰符控制的是对类中的封装的状态以及控制实例行为的方法的访问权。对象中封装的变量和方法是由四种类型的修饰符控制的。</p>
<table>
<thead>
<tr>
<th align="center">可见性</th>
<th align="center">修饰符</th>
<th align="center">可见范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最低</td>
<td align="center">private</td>
<td align="center">同一个类的任何实例可见，子类不可见</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><none></td>
<td align="center">同一个包中的任何类可见</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">protected</td>
<td align="center">任何子类可见</td>
</tr>
<tr>
<td align="center">最高</td>
<td align="center">public</td>
<td align="center">任意位置可见</td>
</tr>
</tbody></table>
<p>记住，private成员变量只能在所有的内使用，甚至不能在子类中访问：private变量就应该用于所在的类本身，而不能用于其他任何类。</p>
<p>关于private修饰符有一个常见的误解，那就是认为private变量只能被所在的实例访问。事实上，实例可以访问同一个类型的其他任意实例的private成员变量。</p>
<p>访问同一个类型不同实例的private成员变量的两种情形。大部分优秀的集成开发环境都会帮助生成hashCode和equals方法：这些方法在判定实例是否相等时都会访问其他实例的private成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> real;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> imaginary;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Complex</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> r,<span class="keyword">final</span> <span class="keyword">double</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.real=r;</span><br><span class="line">        <span class="keyword">this</span>.imaginary=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Complex <span class="title">add</span><span class="params">(<span class="keyword">final</span> Complex other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(<span class="keyword">this</span>.real+other.real,</span><br><span class="line">                          <span class="keyword">this</span>.imaginary+other.imaginary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为简洁省略了hashCode</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==o)</span><br><span class="line">            <span class="keyword">return</span> ture;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="keyword">null</span>||getClass()!=o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        Complex complex=(Complex)o;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Double.compare(complex.imaginary,imaginary,imaginaryy)!=o.getClass())</span><br><span class="line">        <span class="keyword">if</span>(Double.compare(complex.real,real)!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complexNumberAddition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Complex expected=<span class="keyword">new</span> Complex(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Complex a=<span class="keyword">new</span> Complex(<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> Complex b=<span class="keyword">new</span> Complex(-<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    assertEquals(a.add(b),excepted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<strong><em><u>对于方法和变量来说，static修饰符表示什么意思？</u></em></strong>==</p>
<p>类中定义的静态方法和变量属于类，但是不属于某个实例。静态方法和变量是所有实例共享的，通常通过类名来访问，而不是通过某个具体的实例来访问。</p>
<p>类的成员变量既可以通过实例访问也可以通过类本身访问。建议仅通过类名访问静态方法和变量，因为通过实例访问可能会导致混淆：对类定义不熟悉的其他开发者可能会认为这是实例的成员，如果修改了静态变量的值，其他实例会产生异常的行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> EXAMPLE_VALUE=<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">staticVariableAccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    assertEquals(ExampleClass.EXAMPLE_VALUE,<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    ExampleClass c1=<span class="keyword">new</span> ExampleClass();</span><br><span class="line">    ExampleClass c2=<span class="keyword">new</span> ExampleClass();</span><br><span class="line">    c1.EXAMPLE_VALUE=<span class="number">22</span>;<span class="comment">//合法，但不推荐</span></span><br><span class="line">    assertEquals(ExampleClass.EXAMPLE_VALUE,<span class="number">22</span>);</span><br><span class="line">    assertEquals(c2.EXAMPLE_VALUE,<span class="number">22</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态（polymorphism)和继承(inheritance)是什么？</p>
<p>多态和继承是面向对象开发中的两个核心概念。</p>
<p>通过多态可以为某一特定类型的行为进行定义，并且可以针对这种行为提供多种不同的实现类。通过继承，可以在定义一个类时从父类继承行为。</p>
<p>定义新的类时，可以从之前定义的继承定义和状态，然后在自己的类中添加新的行为，或在新的类中覆盖原父类中的行为。</p>
<p>在下面的代码中，Square类继承自Rectangle类（可以说，正方形是一个（is-a）矩形）。在Square的定义中，用于保存边长的变量被重用，而Square类强制width和height保持一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> height;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> width,<span class="keyword">final</span> <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width=width;</span><br><span class="line">        <span class="keyword">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> sideLength)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sideLength,sideLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑之前定义的is-a关系，可以这样看待多态：在访问父类时，实际使用的时一个子类。虽然实际的行为是由子类提供的，但是多态的调用者并不知道这一点。</p>
<p>下面的代码展示了使用多态的Square和Rectangle类。在ArrayList看来，它只是在和Rectangle打交道，它不明白，也没必要明白Rectangle和Square之间的区别。考虑到一个Square就是一个Rectangle，因此这段代码可以正常工作。如果Square类定义了任何特别的方法，那么Rectangle列表的用户无法使用这些方法，因为在Rectangle类中并没有这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">polymorphicList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Rectangle&gt; rectangles=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    rectangles.add(<span class="keyword">new</span> Rectangle(<span class="number">5</span>,<span class="number">1</span>));</span><br><span class="line">    rectangles.add(<span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">10</span>));</span><br><span class="line">    rectangles.add(<span class="keyword">new</span> Square(<span class="number">9</span>));</span><br><span class="line">    </span><br><span class="line">    assertEquals(rectangle.get(<span class="number">0</span>).area(),<span class="number">5</span>);</span><br><span class="line">    assertEquals(rectangle.get(<span class="number">1</span>).area(),<span class="number">20</span>);</span><br><span class="line">    assertEquals(rectangle.get(<span class="number">2</span>).area(),<span class="number">81</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>==<u><strong>解释Object类被继承时一些会被重写的方法。</strong></u>==</em></p>
<p>运行在JVM上的每一个类都是从java.lang.Object继承而来的，因此这个类中所有非final的public和protected方法都可以被重写。</p>
<p>equals（Object other）方法的用途是：测试两个引用表示的对象是否逻辑上相等。对于集合类，例如java.util.TreeSet和java.util.HashMap等，利用对象的equals方法判定对象是否已经在集合中存在。Object实现的equals方法比较的是对象在内存中的位置，如果两个对象在内存中位于同一个位置，那么这两个对象实际上就是同一个对象，因此必然相等。这种比较实际上没有多大用，而且也不应该是判定相等的正确方法，因此在任何需要判定相等的场合都必须重写这个方法。</p>
<p>hashCode的规则是：对于两个相等的对象，必须返回同一个值。==注意，反过来并没有这样的要求==也就是说，如果两个对象返回的是同一个hashCode，不一定意味着两个对象相等。反过来的这项特性本身是挺好的，但是并不强求：不同实例之间的hashCode差异越大，这些实例在HashMap中的分布性就越好。要注意的是，hashCode返回的是一个int，这意味着如果要求不同的hashCode表示不相等的对象，那么某一个类型的实例最多只能由2^32^种不同的值。这是一个很大的限制，特别是对于String这样的对象来说。</p>
<p>hashCode和equals之间由这样的关系的原因和java.util.HashMap这一类集合类的实现方式有关。支撑HashMap的数据结构是某种类型的表，例如数组或列表。hashCode值的作用是判定表中要使用的索引值。由于hashCode返回的是int，所以返回的值有可能为负数，也有可能返回比表的大小要大的值。任何HashMap的实现都会对这个值进行操作，从而得到合法的表索引值。</p>
<p>和equals一样，Object类的hashCode方法也是通过内存位置生成hashCode值的。这意味着两个在不同位置但是逻辑上相等的实例返回的hashCode会不同。</p>
<p>下面的代码中Set实现的行为不符合预期。代码中的集合不知道如何正确的比较Person对象，因为Person对象没有实现equals。只要实现一个比较name字符串和age整数的equals方法即可修复这个实现的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.hashCode()*age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrongSetBehavior</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Person&gt; people=<span class="keyword">new</span> HashSet&lt; &gt;();</span><br><span class="line">    <span class="keyword">final</span> Person person1=<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    <span class="keyword">final</span> person person2=<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">final</span> Person person3=<span class="keyword">new</span> Person(<span class="string">&quot;Charlie&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> person1Added=people.add(person1);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> person2Added=people.add(person2);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> person3Added=people.add(person3);</span><br><span class="line">    </span><br><span class="line">    assertTure(person1Added &amp;&amp; person2Added &amp;&amp; person3Added);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逻辑上等于person1</span></span><br><span class="line">    <span class="keyword">final</span> Person person1Again=<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    <span class="comment">//应该返回false，因为Alice已经在集合中了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> person1AgainAdded=people.add(person1Again);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//但是会返回ture，因为没有实现equals方法</span></span><br><span class="line">    assertTrue(person1AgainAdded);</span><br><span class="line">    assertEquals(<span class="number">4</span>,people.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据hashCode和equals方法之间的关系，有这样一条重要规则：如果要重写hashCode或equals方法，那么这两个方法都必须重写。事实上，像IntelliJ和Eclipse这样的IDE不允许在生成一个方法的情况下不生成另一个方法。</p>
<p>尽管相等的对象必须返回同一个hashCode，但是反过来不一定是这样。</p>
<p>如下为一个合法的hashCode()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这种写法是不可取的。因为HashMap（以及HashMap支撑的HashSet）通过hashCode方法计算保存对象引用的表索引。如果不相等的对象具有相同的hashCode值，那么这些对象都会通过LinkedList数据结构保存在同一个索引。</p>
<p>如果所有要保存在一个HashMap中的对象都会返回同一个hashCode，那么这个HashMap的性能就降级为链表的性能了：所有的对象都保存在HashMap中的同一个槽中。寻找值的操作需要遍历所有对象的值，一个一个地判定是否相等。</p>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p><strong><em><u>==数组在Java中是怎样表示的？==</u></em></strong></p>
<p>关于Java中的数组，要记住的一件最重要的事情就是：数组也是对象。数组可以像对象一样的操作。可以对数组调用toString()(尽管没什么用)，还可以以多态方式使用数组，例如将数组保存在一个Object容器中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arraysAsbjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; mapping=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    mapping.put(<span class="string">&quot;key&quot;</span>,<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    assertTure(mapping.get(<span class="string">&quot;key&quot;</span>) <span class="keyword">instanceof</span> (<span class="keyword">int</span>[]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于数组就是对象，所以数组是通过引用传递的，因此通过数组的引用就可以以某种方式修改数组。</p>
<p>下面的代码演示了数组的修改，这种方式可能会引起很大的困惑，因为数组可能会在代码的其他位置被修改，甚至可能在不同的线程中被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrayReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] myArray=<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] arrayReference2=myArray</span><br><span class="line">        </span><br><span class="line">        arrayReference2[<span class="number">5</span>]=<span class="number">99</span>;</span><br><span class="line">    </span><br><span class="line">    assertFalse(myArray[<span class="number">5</span>]==<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String的使用"><a href="#String的使用" class="headerlink" title="String的使用"></a>String的使用</h2><p><strong><em><u>==String在内存中是怎样保存的？==</u></em></strong></p>
<p>使用Java的一大好处就是所有的库实现都可以查看。下面代码表示Java1.7中String的实现看上去不会太出格。String表示的值通过char数组来保存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">	<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,</span></span><br><span class="line"><span class="class">	<span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String类在Java语言中的地位非常核心，使用非常广泛，因此尽管String只是Java库中定义的一个类，但是JVM和编译器都会在特定的情形下以特别的方式处理String。因此几乎将String看成是原始类型。</p>
<p>在创建String字面量时，没必要，也最好不要调用new。在编译时，String字面量——–即一对引号之间所有字符——–都会被创建为String。</p>
<p>下面代码中的两个String是一样的，在任何运行的程序中都可以当成同一个值来处理。首先看helloString的构建：当编译器看到字符序列“，H，e，…..,!,”时，编译器就知道要创建一个String字面量，其值为双引号之间的字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringCreation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String helloString1=<span class="keyword">new</span> String(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">		String helloString2=<span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		assertEquals(helloString1, helloString2);</span><br></pre></td></tr></table></figure>

<p>当编译器处理helloString1时，看到引号之间的字符，也会为这个值创建一个String对象。由于这个String字面量出现在一个构造函数的调用中，所以这个对象也被传入构造函数。后面会提到，由于String是不可变的，所以构造函数会对传入的值做一份拷贝。构造函数String(char[]）会对这个数组做一次完整拷贝。当试图向String构造函数中传入一个String字面量时，大部分IDE都会生成一条警告———这种操作是没有必要的。</p>
<p><strong><em><u>==可不可以修改一个String的值？==</u></em></strong></p>
<p>查看String支持的方法，可以发现所以看上去修改String的方法实际上都会返回一个String实例。</p>
<p>尽管下面的代码并不显得非常意外，但是确实能体现String的一个最重要的行为：String的值永远不会变化。String是不可变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringChanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> String greeting=<span class="string">&quot;Good Morning, Dave&quot;</span>;</span><br><span class="line">	<span class="keyword">final</span> String subString=greeting.substring(<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	assertTrue(subString.equals(<span class="string">&quot;Good&quot;</span>));</span><br><span class="line">	assertFalse(greeting.equals(subString));</span><br><span class="line">       assertTrue(greeting.equals(<span class="string">&quot;Good Morning, Dave&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码表面，看上去“修改”String的方法，例如上述代码中使用的substring，以及其他的如replace和split方法，返回的都是新的字符串拷贝，新字符串的内容做了相应的修改。</p>
<p>实例表示的值永远不会发生变化，有了这个关于不可变性的认识可以有很多好处。不可变对象都是线程安全的：这种对象可以用于很多个并发线程中，每一个线程都知道对象的值永远都不会变化，因此不需要使用锁机制或复杂的线程同步机制。</p>
<p>String并不是Java标准库中唯一的不可变类。所有的数值类，例如Integer，Double，Character和BigInteger都是不可变的。</p>
<p><strong><em><u>==什么是驻留（interning）？==</u></em></strong></p>
<p>继续之前对String字面量和不可变性的讨论，JVM在运行时会对字面量有特别的关照。当JVM加载类时，会将所有的字面量保存在一个常量池中。如果出现了重复的String字面量，那么重复字面量可以通过池中已经存在的相同常量来引用。这种技术称为String驻留（interning）。</p>
<p>显然，由于这个池中的常量可以被JVM中运行时任意类引用，同时发生的引用可能会轻易达到成千上百，因此String的不可变性变得非常有必要。</p>
<p>String字面量并不是String驻留池的唯一用户，任何String实例都可以通过intern()</p>
<p>方法添加到这个池中。如果要对来自一个文件或网络连接的大量数据进行解析，而且这些数据可能包含大量的重复内容，那么可以使用String驻留技术，这是一种政党的使用场景。想象一下有一个巨大的银行对账单，其中包含很多来自某一方的借贷交易或借记交易，或者包含了类似于多次购买同一个产品的重复相似交易。如果这些条目在读入时都驻留化了，那么在JVM中只有一个占用内存的实例。String类的equals方法也会检查两个被比较对象的实例引用的是否是内存中的同一个位置，因此，String相等时的比较会非常快。</p>
<p>注意intern()方法也是有代价的：尽管这些String不是保存在堆上，但是也需要保存在其他地方，即PermGen空间。</p>
<p>如果对intern()的滥用导致常量池中存在很多条目，例如数百万条目，那么每一个条目的查询开销也会对应用程序的运行性能造成影响。</p>
<p>String常量池是享元模式的一种实现，在Java库中还有其他地方也使用了类似这样的模式。例如，下面的代码展示了对于值在-128和127之间的Integer对象来说，方法Integer.valueOf(String)会返回同一个Integer对象实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">intEquality</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//为了让String出现在不同的内存位置中，</span></span><br><span class="line">		<span class="comment">//显式地调用new String</span></span><br><span class="line">		<span class="keyword">final</span> Integer int1=Integer.valueOf(<span class="keyword">new</span> String(<span class="string">&quot;100&quot;</span>));</span><br><span class="line">		<span class="keyword">final</span> Integer int2=Integer.valueOf(<span class="keyword">new</span> String(<span class="string">&quot;100&quot;</span>));</span><br><span class="line">		</span><br><span class="line">		assertTrue(int1==int2);</span><br></pre></td></tr></table></figure>

<p>通过相等性判断，这段代码确保了这些对象引用的是内存中的同一个实例（JUnit 的Assert.assertSame()也能实现同样的判定，但是这里结合==使用assertTrue()看上去更清楚）。</p>
<h2 id="理解泛型"><a href="#理解泛型" class="headerlink" title="理解泛型"></a>理解泛型</h2><p><strong><em><u>==解释如何结合泛型使用Collections API。==</u></em></strong></p>
<p>泛型(generic)也称为模板化类型(parameterized type)。结合泛型使用Collections类时，编译器就知道约束集合只允许包含特定类型的对象。</p>
<p>下面的代码是完全合法的：代码将String添加到一个List实例，然后通过这个实例访问String。get方法返回一个Object，因为List是多态的。List类能够处理任意类型的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List authors;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Author</span><span class="params">(<span class="keyword">final</span> String name)</span></span></span><br><span class="line"><span class="function">		</span>&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAuthors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		authors=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		</span><br><span class="line">		authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;Stephen Hawking&quot;</span>));</span><br><span class="line">		authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;Edgar Allan Poe&quot;</span>));</span><br><span class="line">		authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;William Shakespeare&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authorListAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">final</span> Author author=(Author) authors.get(<span class="number">2</span>);</span><br><span class="line">			assertEquals(<span class="string">&quot;William Shakespeare&quot;</span>, author.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		 </span><br></pre></td></tr></table></figure>

<p>由于列表没有被约束为只允许包含Author类的实例，所以下面的代码也是合法的，这反映了一个开发者可能犯的简单错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List authors;</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useStrings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		authors.add(<span class="string">&quot;J.K.Rowling&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> String authorAsString=(String)authors.get(authors.size()-<span class="number">1</span>);</span><br><span class="line">		assertEquals(<span class="string">&quot;J.K.Rowling&quot;</span>, authorAsString);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码对列表中的实例没有任何约束。从上述代码可以看出几个问题。是否可以绝对的肯定列表中只有这些类型的对象？如果不是的话，运行时会抛出ClassCastException异常。而类型转换本身就是很糟糕的代码。</p>
<p>通过使用泛型，运行时可能会发生的异常会转变为编译错误。在开发生命周期中，编译错误会被更早的发现，因此也可以更快的修复错误，并且得到更简洁的代码。如下代码展示了泛型的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Author&gt; authors;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Author</span><span class="params">(<span class="keyword">final</span> String name)</span></span></span><br><span class="line"><span class="function">   </span>&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAuthors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   authors=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">   authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;Stephen Hawking&quot;</span>));</span><br><span class="line">   authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;Edger Allan Poe&quot;</span>));</span><br><span class="line">   authors.add(<span class="keyword">new</span> Author(<span class="string">&quot;William Shakespeare&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">  	</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authorListAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Author author=authors.get(<span class="number">2</span>);</span><br><span class="line">   assertEquals(<span class="string">&quot;William Shakespeare&quot;</span>, author.getName());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中没有为访问数据而使用的类型转换，读起来更加自然：“从作者列表中获得第3位作者”。</p>
<p>authors实例被限定为只能接受类型为Author的对象。另一个测试useStrings现在根本就通不过编译。编译器会注意到这个错误。将这个测试从使用String修改为使用Author就可以轻松修复这个错误。</p>
<p>集合API中的所有类都使用了泛型。根据现在已经看到的例子，List接口及其实现接受一个类型参数。Set也是一样。不出所料，Map接受两个类型参数，一个表示键的类型，另一个表示值的类型。</p>
<p>泛型类型还可以嵌套。比如说可以这样合法地定义一个Map： HashMap&lt;Integer,List<String>&gt;,这表示一个将Integer类型的键映射到String类型的List的HashMap。</p>
<p><strong><em><u>==修改给定的栈API，使其使用泛型==</u></em></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List values;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		values=<span class="keyword">new</span> LinkedList();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">		values.add(<span class="number">0</span>,object);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(values.size()==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> values.remove(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈的实现在面试中是一个非常常见的问题。栈支持的操作集比较小，通常包括push和pop，有时候还可能包括peek。栈通常是使用Java集合API实现的，不需要其他的库。花一点时间确认自己是否真正理解了为什么这里使用的是LinkedList——–是不是也能使用ArrayList？两者之间有何区别？</p>
<p>针对这个给定的实现，这是一个全功能的栈，不过还不支持使用泛型。这个实现会遇到前一个问题中讨论的所有问题。</p>
<p>为了将这个类逐渐迁移至使用泛型，可以在编译器的指导下完成。首先，必须将Stack类声明为接受被参数化的类型：</p>
<p><code>public class GenericStack&lt;E&gt;&#123;</code></p>
<p><code>values.add(0,element);</code></p>
<p><code>&#125;</code></p>
<p>将values修改为List<E>还会在Stack的构造函数中产生一个编译器警告。在创建values LinkedList时，也需要参数化：</p>
<p><code>public GenericStack() &#123;</code></p>
<p><code>values=new LinkedList&lt;E&gt;();</code></p>
<p><code>&#125;</code></p>
<p>编译器注意不到的一个变化是pop方法的变化。pop方法的最后一行values.remove(0)现在返回的是类型为E的值。而目前，这个方法返回的是Object。编译器没有理由对此报错或给出警告，因为Object是所有类的超类，而不论E表示什么具体类型。对此，可以将返回类型修改为E：</p>
<p><code>public E pop() &#123;</code></p>
<p><code>if (values.size()==0) &#123;</code></p>
<p><code>return null;</code></p>
<p><code>&#125;</code></p>
<p><code>return values.remove(0);</code></p>
<p><code>&#125;</code></p>
<p><strong><em><u>==类型变体（type variance)对泛型有什么影响？==</u></em></strong></p>
<p>假定有以下类层次关系：</p>
<p><code>class A &#123;&#125;</code></p>
<p><code>class B extends A &#123;&#125;</code></p>
<p>B是A的一个子类。但是List<B>不是List<A>的一个子类。这种变体称为类型协变(covariance),Java的泛型系统无法对此进行建模。</p>
<p>在使用泛型类型时，有时候可能需要接受一个类的子类作为参数。例如针对前一个问题中的GenericStack类，假设有一个工具方法通过A的List创建一个新的GenericStack：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GenericStack&lt;A&gt; <span class="title">pushAllA</span><span class="params">(<span class="keyword">final</span> List&lt;A&gt; listOfA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> GenericStack&lt;A&gt; stack=<span class="keyword">new</span> GenericStack&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(A a: listOfA) &#123;</span><br><span class="line">        stack.push(a);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这段代码可以正常编译，而取对于A的List来说运行结果完全符合预期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> usePushAllA &#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;A&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> GenericStack&lt;A&gt; genericStack=pushAllA(list);</span><br><span class="line">    </span><br><span class="line">    	assertNotNull(genericStack.pop());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果试图向B添加元素，则无法通过编译:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usePushAllAWithBs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;B&gt; listOfBs=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        listOfBs.add(<span class="keyword">new</span> B());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> GenericStack&lt;A&gt; genericStack = pushAllA(listOfBs);</span><br><span class="line">    </span><br><span class="line">    assertNotNull(genricStack.pop());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管B是A的子类，但是List<B>并不是List<A>的子类。pushAllA的方法签名应该修改为显式地允许类型A，以及A的任何子类：</p>
<p><code>public static GenericStack&lt;A&gt; pushAllA(final List&lt;? extends A&gt; listOfA)&#123;</code></p>
<p>代码中的问好称为通配符（wildcard），目的是告诉编译器这里允许A的扩展类的任何实例。</p>
<p><strong><em><u>==具体化（reified）是什么意思？==</u></em></strong></p>
<p>本质上说，具体化的意思就是在运行时生效。Java的泛型类型是没有具体化的。意思就是说编译器检查实现代码使用泛型参数是否正确时使用的所有类型信息都不是.class文件中定义的类型信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRefiedExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericTypesCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        strings.add(<span class="string">&quot;Die Hard 4.0&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;Terminator 3&quot;</span>);</span><br><span class="line">        strings.add(<span class="string">&quot;Under Siege 2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(Stirngs.get(<span class="number">2</span>) <span class="keyword">instanceof</span> String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过JAD（一款Java反编译器）对上述代码生成的类文件进行反编译，得到代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRefiedExample</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericTypesCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList arraylist = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arraylist.add(<span class="string">&quot;Die Hard 4.0&quot;</span>);</span><br><span class="line">        arraylist.add(<span class="string">&quot;Terminator 3&quot;</span>);</span><br><span class="line">        arraylist.add(<span class="string">&quot;Under Siege 2&quot;</span>);</span><br><span class="line">        System.out.println(arraylist.get(<span class="number">2</span>) <span class="keyword">instanceof</span> String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的类型信息都丢了，这意味着，如果从一个编译后得到的类文件反编译得到这样的代码，那么必须假定这段代码一定服从编译时使用的泛型参数信息。</p>
<p>从这个例子可以看出，很容易构造出这样的程序：其中使用了一个带有某个泛型类型的List，但是动态加载的实例却是不同的类型。</p>
<p>如果没有提供构造函数，编译器会生成一个默认的构造函数。所有的类都必须至少有一个构造函数。</p>
<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p><em>==<u>原始类型的访问可能 抛出NullPointerException异常吗？</u>==</em></p>
<p>这个问题的答案是不可能的，但实际上好像会有这样的现象。以下面的代码为例，有几点需要注意的地方。当给intObject赋值42时，实际上是在将原始类型值42赋值给一个对象。这种行为本来是不合法的，而且在Java5之前，这样确实会产生编译错误。然而现在的编译器会使用一种称为自动装箱（autoboxing）的技术。编译器知道int类型对应的引用类型是Integer，因此这种行为是合法的。如果编译器不能感知这两种类型之间的关系（Java5之前这样），那么如果需要一个对Integer对象的引用，就需要自己手工完成：既可以使用new Integer(42),也可以使用效率更高的Integer.valueOf(42)。</p>
<p>Integer.valueOf(42)效率更高的原因是小值会被缓存。此缓存模式称为享元模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">primitiveNullPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Integer intObject = <span class="number">42</span>;</span><br><span class="line">		<span class="keyword">assert</span>(intObject == <span class="number">42</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> newIntValue = methodWhichMayReturnNull(intObject);</span><br><span class="line">			fail(<span class="string">&quot;Assignment of null to primitive should throw NPE&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">			<span class="comment">//误操作，测试成功</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Integer <span class="title">methodWhichMayReturnNull</span><span class="params">(Integer intValue)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动装箱和装箱的区别</p>
</blockquote>
<blockquote>
<p>Java5引入了自动装箱的概念。自动装箱指的是自动地将原始类型转换为对应的引用类型，例如boolean，转换为Boolean，以及int转换为Integer。</p>
<p>在Java5之前，这种操作必须手工完成，即装箱操作。为了将int转换为Integer，必须构造一个(new Integer(42))，或使用工厂模式（Integer.valueOf(42))。</p>
</blockquote>
<p>将装箱的引用类型，例如Float， Integer 和 Boolean 转换为对应原始类型的 float, int 和 boolean 的过程称为拆箱。同样，这也是编译器提供的一个操作。不过此时应该警惕的问题是，只要要使用引用类型，就必须注意引用为null的情况，对于装箱类型来说就是如此。当编译器将Integer转换为int时，编译器会假定被转换的值不为null，因此如果被转换的类型为null，那么会立即抛出NullPointerException异常。try代码块中的第一行代码将类型为Integer的方法返回值赋给原始类型int。在这个例子中总是返回null，因此运行这一行时一定会抛出NullPointerException异常。因为无法将null值赋给原始类型。当尝试调用或修复相关问题时，特别是不很清楚哪里发生了装箱和拆箱操作时，这样的行为可能会导致挫败感和混乱感。</p>
<p>原始类型不能用于泛型类型定义，也就是说不能有类似List<int>这样的类型。在使用泛型的情况下必须使用引用类型。</p>
<h2 id="使用注记"><a href="#使用注记" class="headerlink" title="使用注记"></a>使用注记</h2><p><strong><em><u>==给出一个使用注记（annotation）的例子。==</u></em></strong></p>
<p>注记是在Java5中引入的，JUnit库从JUnit4开始充分利用了这些注记。</p>
<p>下面的代码展示了JUnit4之前测试是如何工作的。编写测试套件时，测试的命名采用特定的约定，此外测试运行之前和之后要运行的步骤也采用特定的命名约定。JUnit运行器会通过反射技术查看TestCase子类编译得到的测试。如果找到了public void setUp()这样的方法签名，那么每一个测试运行之前都会运行这个方法。所有返回类型为void 的公共方法以及名字以test开头的方法都会被当成测试来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit3Example</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> myInt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myInt = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">textMyIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">42</span>, myInt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myInt = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>text前缀的输入错误，或setUp以及tearDown的拼写错误都可能导致测试无法进行，而且不会有任何错误提示。更糟糕的是，测试可能会失败。</p>
<p>随着注记的引入，这种脆弱的命名约定可以被抛弃了，取而代之的是通过注记来标注相应的方法，因此允许测试使用表达性更好的定义。下面的代码展示了同一个测试使用注记之后的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit4Example</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> myInt;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Before</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assignIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			myInt = <span class="number">42</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkIntValueIsCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Assert.assertEquals(<span class="number">42</span>, myInt);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@After</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsetIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			myInt = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>即使你没有任何和JUnit相关的经验，也很容易理解使用注记对于测试来说是很好的：方法可以有更好的名字，而且方法可以有多个注记。一个方法可以既有@Before又有@After注记也是可行的，这样可以避免代码重复。</p>
<p><strong><em>==@Override注记有什么用？==</em></strong></p>
<p>@Override 注记表示一个非常有用的编译时检查。这条指令告诉编译器，有一个父类的方法要被重写。如果在父类中没有匹配的方法签名，那么表示出现了一个错误，编译应该停止。</p>
<p>一般来说，这是避免在重写方法时产生错误的绝好方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GENERIC VEHICLE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CAR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，getrame()方法貌似被重写为返回描述性更强的内容，但是以下代码实际上会打印出GENERIC VEHICLE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car c = <span class="keyword">new</span> Car();</span><br><span class="line">System.out.println(c.getName());</span><br></pre></td></tr></table></figure>

<p>这是因为Car类中有一个拼写错误：类中的方法是 getname() 而不是 getName() 。Java中所有的标识符都是大小写敏感的。这种bug 的追查特别痛苦。</p>
<p>如果在重写 getName() 方法时添加标记@Override，那么编译器就会在这里标出一个错误。这个错误很快就可以得到修复。</p>
<p>和王超一样，你因该使用专业水准的IDE，并且尽可能利用IDE提供的帮助。IntelliJ和Eclipse都提供了重写方法的向导对话框，这样就可以准确地选择你想要重写的方法。这些向导会自动添加@Override 注记，因此想错也错不了。</p>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>当面试官在看示例代码时，不论代码是来自面试题还是候选人的示例代码（肯是从Github或类似的网站上摘取的代码），他们都会考察代码的质量，从final关键字的使用到变量命名的约定都会被考察到。IDE对命名约定的支持是非常棒的，而且几乎没有什么理由要拒绝这些约定。IDE有助于代码更容易被同事和评审人接受。</p>
<p>==类==</p>
<p>类总是以大写字母开头，并且采用骆驼命名法（CamelCase):</p>
<ul>
<li>Boolean</li>
<li>AbstractJUnit4SpringContextTests</li>
<li>StringBuilder</li>
</ul>
<p>==变量和方法==</p>
<p>变量和方法总是以小写字母开头，并且也采用骆驼命名法：</p>
<ul>
<li>int myInteger = 56;</li>
<li>public String toString();</li>
</ul>
<p>==常量==</p>
<p>static final 实例变量永远不会变化，因此也称为常量。常量的命名约定是全部大写，单词之间通过下划线隔开：</p>
<ul>
<li>public static final int HTTP_OK = 200;</li>
<li>private static final String EXPECTED_TEST_RESPONSE = “YES”;</li>
</ul>
<p>争论比较多的是如何骆驼命名法对缩写正确地命名。接受度高的是第一个字母大写，其他字母小写，例如 HttpURLConnection 在一个类中使用了两种风格！</p>
<p>从作者他的角度来看，大写第一个字母的方法更容易接受，因为这样可以更清楚地看到缩写词在哪里结束以及下一个单词在哪里开始。现在很多IDE，可以仅通过输入骆驼命名法中每一个单词首字母来搜索类。</p>
<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p><strong>==<em><u>描述Java异常层次结构中的核心类。</u></em>==</strong></p>
<p>下图展示了异常层次结构，并且给每一个类型都附了例子。</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201113201227.png" alt="image-20201113200626814"></p>
<p>所有可以被抛出的类都是对Throwable的扩展。Throwable有两个直接子类：Error和Exception。按照惯例，在必要时抛出并解决Exception一般是开发人员的职责。而Error则是无法恢复的问题，例如OutOfMemoryError和NoClassDefFoundError。</p>
<p>异常本身的定义分为两类：一个异常既可以指运行时异常（runtime exception），也可以指检查异常（checked exception）。运行时异常由RuntimeException的子类表示。检查异常则时任何其他的异常。</p>
<p>如果一个方法（或构造函数）可能会抛出检查异常，那么在方法定义中应该显式地定义这个异常。这个方法所有的调用者都必须准备好处理这个异常，处理的方法既可以是将异常抛出给调用自己的方法，也可以是将方法调用包装在一个try/catch/finally代码块中，并且根据具体情况处理异常。</p>
<p><strong><em>==运行时异常和检查时异常孰优孰劣？==</em></strong></p>
<p>在使用检查异常时，必须明确告诉用户那些地方可能会出错。在编写可能会抛出检查异常的方法时，要尽可能的声明。像public String getHostName() throws Exception 这样的方法定义给用户关于哪里会出错的信息太少。如果这样定义：public String getHostName() throws UnknownHostException, 那么用户就应该了解哪里可能会出错，而且可以对方法的工作方式有更深入的理解。</p>
<p>关于运行时异常，在方法上定义异常，重抛异常以及使用try/catch/finally 代码块都是可选的。作为一般性的原则，RuntimeException异常是任何一位心细的开发者都应该避免的异常，例如访问数组的索引超出了数组大小的异常 ArrayIndexOutBoundsException 或对 null 引用调用方法的异常 NullPointerException。</p>
<p>在定义API并决定是使用运行时异常还是使用检查异常时，作者他的建议是优先使用运行时异常，并且通过任何形式的文档明确地告诉调用这个方法的客户可能会抛出什么异常。使用try/catch/finally 代码块会添加大量模式化的代码，即使只是最简单的方法调用，因此未来代码的维护会非常困难。比如说观察一下对JDBC的正规调用，就经常会发现在try/catch/finally代码块中嵌套了try/catch/finally代码块。一些现代的编程语言，例如Scala，已经摒弃了异常检查异常，只支持运行时异常。</p>
<p>==<strong><em>什么是异常链(exception chaining)?</em></strong>==</p>
<p>当捕捉一个异常以处理一个错误的情形时，完全可以用重新抛出这个异常，甚至还可以抛出一个不同类型的异常。</p>
<p>需要重新抛出异常的原因包括将一个检查异常转换为一个运行时异常，以及对异常执行一些日志操作然后再重新抛出这个异常。当抛出一个之前已经捕捉到的异常时，建议抛出一个新的异常，并且在这个新的异常中添加一个引用。这种技术称为异常链。</p>
<p>在catch代码块中抛出一个新的异常采用的也是一样的思想。在新异常的构造函数中传入一个指向老异常的引用。</p>
<p>这样做的原因是：在对没有处理的异常进行调试时，这些异常链非常有价值。栈跟踪记录可以在应用程序控制台中输出所有这些信息。</p>
<p>在栈跟踪记录中可以通过”caused by” 行找到这些信息。 这里可以找到被包装前或重新抛出前的原始异常。</p>
<p>下面演示如何创建异常链。catch代码块中的异常实例将其引用传递给IllegalStateException 的构造函数，从而链接到了一个新的IllegalStateException 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exceptions</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">addNumbers</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(first &gt; <span class="number">42</span>)  &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;First parameter must be small&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> first + second;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionChaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				total = addNumbers(<span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;total = &quot;</span> + total);</span><br><span class="line">			&#125;<span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to add munbers together&quot;</span>,e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>Java标准库中的所有异常都可以在构造函数中接受一个 throwable 实例。如果你要创建新的 Exception 类，请一定要遵循这个原则。</p>
<p>当这个测试（不可否认这是一个人为编造的例子）运行时，演示了 IllegalStateException异常确实是因为传入AddNumbers方法的第一个参数的值太高而引起的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalException: Unable to add numbers together</span><br><span class="line">	at com.wiley.acinginterview.chapter08.Exception.exceptionChaining</span><br><span class="line">		(Exceptionns.java:<span class="number">23</span>)</span><br><span class="line">    at sun.reflet.NativeMethodAccessorImpl.invoke()(Native Method)</span><br><span class="line">    ...</span><br><span class="line">    &lt;Exeption truncated&gt;</span><br><span class="line">    ...</span><br><span class="line">    	at sun.reflect.NativeMethodAccessorImpl.invoke</span><br><span class="line">    		(NativeMethodAccessorImpl.java:<span class="number">39</span>)</span><br><span class="line">    	at com.intellij.rt.execution.application.Appain.main</span><br><span class="line">    		(AppMain.java:<span class="number">120</span>)</span><br><span class="line">    Caused by: java.lang.IllegalArgumentException: First parameter must be small</span><br><span class="line">        at com.wiley.acinginterview.chapter08.Exceptions.addNumbers</span><br><span class="line">        	(Exceptions.java:<span class="number">9</span>)</span><br><span class="line">        at com.wiley.cinginterview.chapter08.Exceptions.exceptionChaining</span><br><span class="line">        ...<span class="number">26</span> more</span><br></pre></td></tr></table></figure>

<p>如果异常没有串联在一起，而且try代码块中的代码规模大得多，那么要找到最初的异常是从哪里抛出的会是一件非常耗时的体力活。</p>
<p>如果发现catch代码块中抛出了一个异常，而且没有链接到原始异常，那么请在这里添加一个指向原始异常的引用。以后你会庆幸自己这么做了！</p>
<p>​            <strong><em><u>==try-with-resources语句是什么？==</u></em></strong></p>
<p>Java7 为try/catch/finally 语句引入了一种语法糖。如果一个类实现了 AutoCloseable 接口，那么不需要担心资源关闭的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demonstrateResourceHandling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(<span class="keyword">final</span> FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;/tmp/dataFile&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>];</span><br><span class="line">			reader.read(buffer);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// ...处理异常</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在引入 try-with-resources 语句之前，reader实例应该显示地关闭，而如果关闭操作失败的话，关闭本身也会抛出异常或不确定的行为。在更糟糕的情况下，甚至可能会忘记关闭。</p>
<p>AutoCloseable 接口指定了一个方法 close(), 这个方法会在try 代码块之后调用， 就好像在代码块的finally 部分调用一样。</p>
<h2 id="使用Java标准库"><a href="#使用Java标准库" class="headerlink" title="使用Java标准库"></a>使用Java标准库</h2><p>Java标准库中的API 涵盖了很多领域，从数据库访问到优化的搜索和排序算法，从并发相关的API到两个用户界面框架， 无所不包。</p>
<p><strong><em><u>==为什么私有字段还需要通过标记 final 设置为不可变？==</u></em></strong></p>
<p>如果有一个 final 类没有可访问的setter 方法， 而且所有的字段都是私有的，那么你可能会认为这个类是不可变的， 如下面的代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BookRecord</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    ptivate String bookTitle;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookRecord</span><span class="params">(String author, String bookTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>,bookTitle = bookTitle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookTitle</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> bookTIitle;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，事实并非想象的这样。通过反射 API（Reflection API）依然可以操纵这些字段，反射机制有能力访问并修改所有字段，不论这些字段的可见性如何。final 修饰符可以告诉JVM这些字段绝对不允许修改。尽管这种允许访问外界标记不可访问状态的方法看上去有点猥琐，但却是存在一些合法的情形是这么做的。 在 Spring 框架的控制翻转（Inversion of Control)容器中， 当容器在运行时被初始化时会对带有@Autowired注记的私有字段进行设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mutateBookRecordState</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException,</span></span><br><span class="line"><span class="function">											   IllegalAccessException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> BookRecord record = <span class="keyword">new</span> BookRecord(<span class="string">&quot;Suzanne Collins&quot;</span>,</span><br><span class="line">												 <span class="string">&quot;The Hunger Games&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Field authorField = record.getClass().getDeclaredField(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">		author.setAccessible(ture);</span><br><span class="line">		author.set(record,<span class="string">&quot;Catching Fire&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		assertEquals(<span class="string">&quot;Catching Fire&quot;</span>, record.getAuthor());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>除非编写自己的框架 一般来说很少需要修改私有字段的值，特别是那些自己没有控制权的类。</p>
<p><strong><u><em>所有的集合API类都是从哪些类继承而来的？</em></u></strong></p>
<p>大致来说，集合框架包含三大类定义：各种Set 各种list以及各种Map。 还有一个专门的Queue接口，这个接口提供了一些关于队列元素的简单操作，包括添加，删除和查看。ArrayList类既是一个List又是一个Queue。Java Collections框架包含在java.util包中。所有的单元素集合都实现了Collection接口，该接口指定了一些针对整体的方法，例如删除所有元素的 clear()方法和统计集合中有多少条目的size()方法。映射的实现没有实现Collection接口。Java倾向于将映射和集合区分开。当然，Collection 和 Map 还是有关联的：Map接口包含的 entrySet(), keySet() 和values() 方法都以 Collection 的形式返回 Map 中的不同数据。</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201114155039.png" alt="image-20201114154852490"></p>
<p><strong><u><em>什么是LinkedHashMap？</em></u></strong></p>
<p>LinkedHashMap的名字看上去令人困惑———到底是不是HashMap呢？ 又是在何种意义上的链接(linked)？</p>
<p>LinkedHashMap 具有 HashMap 的所有特性——–即根据键索引快速查找元素——–但同时还能保留进入映射数据结构条目的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLinkedHashmapProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> LinkedHashMap&lt;Integer,String&gt; linkedHashMap = <span class="keyword">new</span></span><br><span class="line">				LinkedHashMap&lt;&gt;();</span><br><span class="line">		linkedHashMap.put(<span class="number">10</span>, <span class="string">&quot;ten&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">30</span>, <span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">40</span>, <span class="string">&quot;forty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">50</span>, <span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//工作方式和map一样</span></span><br><span class="line">		assertEquals(<span class="string">&quot;fifty&quot;</span>, linkedHashMap.get(<span class="number">50</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遵循插入的顺序</span></span><br><span class="line">		<span class="keyword">final</span> Iterator&lt;Integer&gt; keyInterator = linkedHashMap.keySet().</span><br><span class="line">				iterator();</span><br><span class="line">		</span><br><span class="line">		assertEquals(<span class="string">&quot;ten&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;twenty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;thirty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;forty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;fifty&quot;</span>,linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//而HashMap却没有这样的特性</span></span><br><span class="line">		<span class="keyword">final</span> HashMap&lt;Integer, String&gt; regularHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		regularHashMap.put(<span class="number">10</span>, <span class="string">&quot;ten&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">30</span>, <span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">40</span>, <span class="string">&quot;forty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">40</span>, <span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> ArrayList hashMapValues = <span class="keyword">new</span> ArrayList&lt;&gt;(regularHashMap.values());</span><br><span class="line">		<span class="keyword">final</span> ArrayList linkedHashMapValues = <span class="keyword">new</span> ArrayList&lt;&gt;(linkedHashMap.values());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//列表中仍然有相同的值，但是顺序不同</span></span><br><span class="line">		assertFalse(linkedHashMapValues.equals(hashMapValues));</span><br><span class="line">	&#125;<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLinkedHashmapProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> LinkedHashMap&lt;Integer,String&gt; linkedHashMap = <span class="keyword">new</span></span><br><span class="line">				LinkedHashMap&lt;&gt;();</span><br><span class="line">		linkedHashMap.put(<span class="number">10</span>, <span class="string">&quot;ten&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">30</span>, <span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">40</span>, <span class="string">&quot;forty&quot;</span>);</span><br><span class="line">		linkedHashMap.put(<span class="number">50</span>, <span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//工作方式和map一样</span></span><br><span class="line">		assertEquals(<span class="string">&quot;fifty&quot;</span>, linkedHashMap.get(<span class="number">50</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遵循插入的顺序</span></span><br><span class="line">		<span class="keyword">final</span> Iterator&lt;Integer&gt; keyInterator = linkedHashMap.keySet().</span><br><span class="line">				iterator();</span><br><span class="line">		</span><br><span class="line">		assertEquals(<span class="string">&quot;ten&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;twenty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;thirty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;forty&quot;</span>, linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		assertEquals(<span class="string">&quot;fifty&quot;</span>,linkedHashMap.get(keyInterator.next()));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//而HashMap却没有这样的特性</span></span><br><span class="line">		<span class="keyword">final</span> HashMap&lt;Integer, String&gt; regularHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		regularHashMap.put(<span class="number">10</span>, <span class="string">&quot;ten&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">30</span>, <span class="string">&quot;thirty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">40</span>, <span class="string">&quot;forty&quot;</span>);</span><br><span class="line">		regularHashMap.put(<span class="number">40</span>, <span class="string">&quot;fifty&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> ArrayList hashMapValues = <span class="keyword">new</span> ArrayList&lt;&gt;(regularHashMap.values());</span><br><span class="line">		<span class="keyword">final</span> ArrayList linkedHashMapValues = <span class="keyword">new</span> ArrayList&lt;&gt;(linkedHashMap.values());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//列表中仍然有相同的值，但是顺序不同</span></span><br><span class="line">		assertFalse(linkedHashMapValues.equals(hashMapValues));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u><em>既然已经有了Hashtable，为什么还要引入HashMap？</em></u></strong></p>
<p>Collections框架和集合类的接口（Collection， Map 和List等）最早出现在Java 1.2版本zhong。而Hashtable类等效于列表的Vector在最初的版本的Java中就存在了。这些类在编写时还没有考虑到框架的问题。当引入Collection框架时，Hashtable被重写以符合Collection接口。</p>
<p>Hashtable类是synchronized，尽管对并行任务很有效，但对单线程任务会有显著的性能开销。而HashMap 不是 synchronized，因此开发者可以自行将这个类的使用调整为满足任何特定的并发需求。建议在并行环境中需要严肃使用Map接口的地方使用ConsurrentHashMap类(Java 5引入)。</p>
<h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><p>Java8可以定义接口的默认实现。如果默认实现足够用了，那么接口的实现者可以不提供自己的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Java8Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alpha</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> beta <span class="keyword">default</span> &#123;<span class="keyword">return</span> <span class="number">6</span>; &#125;;</span><br><span class="line">    String omega <span class="keyword">final</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Cannot override&quot;</span>; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了默认实现之外，接口中还可以包含final实现。现在Java的接口工作方式和抽象类非常接近。</p>
<p>过去几年出现了不少能编译到JVM上执行的语言。其中有一些语言（例如， Scala和Groovy支持lambda表达式，在这些语言中，函数被当成一等公民，函数可以当成变量量传入其他函数或方法。lambda表达式表示的是匿名函数，例子如下，lambda表达式可以用于任何要求只有一个方法的接口的情形。lambda表达式可以内联在代码中，替代完整的接口实现。注意代码中新出现的语法：参数， 箭头， 然后是方法体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ints = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ints.add(<span class="number">1</span>);</span><br><span class="line">    ints.add(<span class="number">2</span>);</span><br><span class="line">    ints.add(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; newInts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ints.forEach(i -&gt; &#123; newInts.add(i+<span class="number">10</span>); &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ints.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">assert</span> ints.size() == newInts.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span> ints.size() == newInts.size();</span><br><span class="line">    System.out.println(<span class="string">&quot;Validated&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List接口，或者更准确地说是 Iterable接口， 添加了一个新的方法：forEach。如果接口不支持默认实现，那么这个方法需要添加到Iterable接口是所有实现中——–不仅仅是Java标准库中的实现需要，所有的第三方代码都需要！</p>
<p>forEach 方法接受的一个参数是新的Consumer 接口的实例。 这个接口有一个方法accept， 这个方法的返回类型为 void，并且接受一个参数。由于只有一个方法，因此这里可以使用lambda 表达式。 当forEach 被调用时，传入这个方法的参数是 Consumer的一个实例，而这个方法的参数类型和列表中的参数类型相同。当遍历列表时，每一个元素都被传递给Consumer的实现。由于Consumer返回的是void， 所以 lambda 表达式不能向调用的方法返回任何值。在上面的代码中，lambda表达式接受每一个元素作为参数， 加上10，然后将得到的值放到新的List没有通过任何途径修改； 检查新的List中保存了正确的值； 检查两个List中都没有多余的元素。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/11/06/%E9%9B%86%E5%90%88/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-11-06</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201105201113.png" alt="image-20201105201104938"></p>
<h3 id="Iterable接口"><a href="#Iterable接口" class="headerlink" title="Iterable接口"></a>Iterable接口</h3><p>（列表爷爷辈的接口）</p>
<p>是新此接口允许对象成为for-each循环的目标，也就是增强for循环，它是Java中的语法糖。</p>
<p><code>List&lt;Object&gt; list=new ArrayList();</code></p>
<p><code>for (Object obj:list)&#123;&#125;</code></p>
<p>除了实现此接口的对象外，数组也可以用for-each循环遍历，如下：</p>
<p><code>Object[] list=new Object[10];</code></p>
<p><code>for(Object obj:list)&#123;&#125;</code></p>
<h5 id="其它遍历方式"><a href="#其它遍历方式" class="headerlink" title="其它遍历方式"></a>其它遍历方式</h5><p>jdk 1.8之前 Iterator只有iterator一个方法，就是</p>
<p>Iterator<T>  iterator();</p>
<p>实现次接口的方法能够创建一个轻量级的迭代器，用于安全的遍历元素，移除元素，添加元素。这里涉及到一个fail-fast机制。</p>
<p>总之一点就是能创建迭代器进行元素和删除的话，就尽量使用迭代器进行添加和删除。也可以使用迭代器的方法来遍历。</p>
<p><code>for(Iterator it=coll.iterator();it.hasNext();)&#123;</code></p>
<p><code>System.out.println(it.next());</code></p>
<p><code>&#125;</code>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p>
<h4 id="顶层接口"><a href="#顶层接口" class="headerlink" title="顶层接口"></a>顶层接口</h4><p>Collection是一个顶层接口，它主要用来定义集合的约定</p>
<p>List接口也是一个顶层接口，它继承了Collection接口，同时也是ArrayList，LinkedList等集合的父类</p>
<p>Set接口位于与List接口同级的层次上，它同时也继承了Collection接口，Set接口提供了额外的规定。它对add，equals，hashCode方法提供了额外的标准。</p>
<p>Queue是和List，Set接口并列的Collection的三大接口之一。Queue的设计用来在处理之前保持元素的访问次序。除了Collection基础的操作之外，队列提供了额外的插入，读取，检查操作。</p>
<p>SortedSet接口直接继承于Set接口，使用Comparable对元素进行自然排序或者使用Comparator在创建时对元素提供定制的排序规则。set的迭代器将按升序元素顺序排列集合。</p>
<p>Map是一个支持key-value存储的对象，Map不能包含重复的key，每个键最多映射一个值。这个接口代替了Dictionary类，Dictionary是一个抽象类而不是接口。</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList是实现了List接口的可扩容数组 （动态数组），它的内部是基于数组实现的。它的具体定义如下：</p>
<p><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;,RandomAccess,Cloneable,java.io.Serializable&#123;...&#125;</code></p>
<blockquote>
<p>ArrayList 可以实现所有可选择的列表操作，允许所有的元素，包括空值。ArrayList还提供了内部存储list的方法，它能够完全期待Vector，只有一点例外，ArrayList还提供了内部存储list的方法，它能够完全替代Vector，只有一点例外，ArrayList不是线程安全的容器。</p>
</blockquote>
<blockquote>
<p>ArrayList有一个容量的概念，这个数组的容量就是List用来存储元素的容量。</p>
</blockquote>
<blockquote>
<p>ArrayList不是线程安全的容器，如果多个线程中至少有两个线程修改了ArrayList的结构的话，就会导致线程安全问题，作为替代条件可以使用线程安全的List，应使用<code>Collections.synchronizedList</code>。</p>
</blockquote>
<p><code>List list=Collections.synchronizedList(new ArrayList(...))</code>。</p>
<blockquote>
<p>ArrayList具有fail-fast快速失败机制，能够对ArrayList作出失败检测。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出<code>ConcurrentModificantionException</code>异常。</p>
</blockquote>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector同ArrayList一样，都是基于数组实现的，只不过Vector是一个线程安全的容器，它对内部的每一个方法都粗暴的上锁，避免多线程引起的安全性问题，但是通常这种同步方式需要的开销比较大，因此，访问元素的效率要远远低于ArrayList。</p>
<p>还有一点在于扩容上，ArrayList扩容后的数组长度会增加50%，而Vector的扩容长度后数组会增加一倍。</p>
<h4 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h4><p>LinkedList是一个双向链表，允许存储任何元素（包括null）。它的主要特征如下：</p>
<blockquote>
<p>LinkedList所有的操作都可以表现为双向性的，索引到链表的操作将遍历从头到尾，视哪个距离近为遍历顺序。</p>
<p>注意这个实现也不是线程安全的，如果多个线程并发访问链表，并且至少其中的一个线程修改了链表的结构，那么这个链表必须进行外部加锁。或者使用</p>
<p><code>List list=Collection.synchronizedList(new LinkedList(...))</code></p>
</blockquote>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>堆栈是我们常说的后入先出（吃了吐）的容器。它继承了Vector类，提供了通常的push和pop操作，以及在栈顶的peek方法，测试stack是否为空的empty方法，和一个寻找与栈顶距离的search方法。</p>
<p>第一次创建栈，不包含任何元素。一个更完善，可靠性更强的LIFO栈操作由Deque接口和他的实现提供，应该优先使用这个类</p>
<p><code>Deque&lt;Integer&gt; stack=new ArrayDeque&lt;Integer&gt;()</code></p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet是Set接口的实现类，由哈希表支持（实际上HashSet是HashMap的一个实例）。它不保证集合的迭代顺序。这个类允许null元素。</p>
<p>注意这个实现不是线程安全的。如果多线程并发访问HashSet，并且至少一个线程修改了set，必须进行外部加锁。或者使用<code>Collections.synchroizedSet()</code>方法重写。</p>
<p>这个实现支持fail-fast机制。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet是一个基于TreeMap的NavigableSet实现。这些元素使用他们的自然排序或者在创建时提供的Comparator进行排序，具体取决于使用的构造函数。</p>
<blockquote>
<p>此实现为基本操作add,remove和contains提供了log（n）的时间成本。</p>
</blockquote>
<blockquote>
<p>注意这个实现不是线程安全的。如果多线程并发访问TreeSet，并且至少一个线程修改了set，必须进行外部加锁。或者使用</p>
</blockquote>
<p><code>SortedSet s=Collections.synchronizedSortedSet(new TreeSet(...))</code></p>
<blockquote>
<p>这个实现特有fail-fast机制。</p>
</blockquote>
<h4 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h4><p>LinkedHashSet继承于Set，先来看一下LinkedHashSet的继承体系：</p>
<p><img src="https://gitee.com/wu-sihui/images/raw/master/img/20201106101914.png" alt="image-20201106101913285"></p>
<p>LinkedHashSet是Set接口的Hash表和 LinkedList的实现。这个实现不同于HashSet的是它维护着一个贯穿所有条目的双向链表。此链表定义了元素插入集合的顺序。注意：如果元素重复新插入，则插入顺序不会受到影响。</p>
<blockquote>
<p>LinkedHashSet有两个影响其构成的参数： 初始容量和加载因子。它们的定义与HashSet完全相同。但注意：对于LinkedHashSet， 选择过高的初始容量值的开销要比HashSet小，因为LinkedHashSet的迭代次数不受容量影响。</p>
</blockquote>
<blockquote>
<p>注意LinkedHashSet也不是线程安全的，如果多线程同时访问LinkedHashSet，必须加锁，或者通过使用</p>
<p><code>Collections.synchronizedSet</code></p>
</blockquote>
<blockquote>
<p>该类也支持fail-fast机制</p>
</blockquote>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>PriorityQueue是AbstractQueue的实现类，优先级队列的元素根据自然排序或者通过在构造函数时期提供Comparator来排序，具体根据构造器判断。PriorityQueue不允许null元素。</p>
<blockquote>
<p>队列的头在某种意义上是指定顺序的最后一个元素。队列查找操作poll，remove，peek和element访问队列头部元素。</p>
</blockquote>
<blockquote>
<p>优先级队列是无限制的，但具有内部capacity，用于控制用于在队列中存储元素的数组大小。</p>
</blockquote>
<blockquote>
<p>该类以及迭代器实现了Collection，Iterator接口的所有可选方法。这个迭代器提供了iterator()方法不能保证以任何特定顺序遍历优先级队列的元素。如果你需要有序遍历，考虑使用Arrays.sort(pq.toArray())。</p>
</blockquote>
<blockquote>
<p>注意这个实现不是线程安全的，多线程不应该并发访问PriorityQueue实例如果某个线程修改了队列的话，使用线程安全的类PriorityBlockingQueue。</p>
</blockquote>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap是一个利用哈希表原理来存储元素的集合，并且允许空的key-value键值对。HashMap是非线程安全的，也就是说在多线程的环境下，可能会存在问题，而Hashtable是线程安全的容器。</p>
<p>HashMap也支持fail-fast机制。HashMap的实例有两个参数影响其性能：初始容量和加载因子。可以使用Collections.synchronizeMap(new HashMap(…))来构造一个线程安全的HashMap。</p>
<h4 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h4><p>一个基于NavigableMap实现的红黑树。这个map根据key自然排序存储，或者通过Comparator进行定制排序。</p>
<blockquote>
<p>TreeMap为containsKey，get，put和remove方法提供了log（n）的时间开销</p>
</blockquote>
<blockquote>
<p>注意这个实现不是线程安全的。如果多线程并发访问TreeMap，并且至少一个线程修改了map，必须进行外部加锁。这通常通过在自然封装集合的某个对象上进行同步来实现，或者使用 SortedMap <code>m=Collections.synchronizedSortedMap（new TreeMap(...))</code>。</p>
</blockquote>
<blockquote>
<p>这个实现持有fail-fast机制。</p>
</blockquote>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>LinkedHashMap是Map接口的哈希表和链表的实现。这个实现与HashMap不同之处在于它维护了一个贯穿其所有条目的双向链表。这个链表定义了遍历顺序，通常是插入map中的顺序。</p>
<blockquote>
<p>它提供一个特殊的LinkedHashMap（int，float，boolean）构造器来创建LinkedHashMap，其遍历顺序是其最后一次的访问顺序。</p>
</blockquote>
<blockquote>
<p>可以重写removeEldestEntry(Map.Entry)方法，以便在将新映射添加到map时强制删除过期映射的策略。</p>
</blockquote>
<blockquote>
<p>这个类提供了所有可选择的map操作，并且允许null元素。由于维护链表的额外开销，性能可能会低于HashMap，有一条除外：遍历LinkedHashMap中的collection-views需要与map.size成正比，无论其容量如何。HashMap的迭代看起来开销更大，因为还要求时间与其容量成正比。</p>
</blockquote>
<blockquote>
<p>LinkedHashMap有两个因素影响了它的构成：初始容量和加载因子。</p>
</blockquote>
<blockquote>
<p>注意这个实现不是线程安全的。如果多线程并发访问LinkedHashMap，并且至少一个线程修改了map，必须进行外部加锁。这通常通过在自然封装集合的某个对象上进行同步来实现Map <code>m=Collections.synchronizedMap(new LinkedHashMap(...))</code>。</p>
</blockquote>
<blockquote>
<p>这个实现持有fail-fast机制。</p>
</blockquote>
<h4 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h4><p>HashMap类实现了一个哈希表，能够将键值映射到值。任何非空对象都可以用作键或值。</p>
<blockquote>
<p>此实现类支持fail-fast机制</p>
</blockquote>
<blockquote>
<p>与新的集合实现不同，Hashtable是线程安全的。如果不需要线程安全的容器，推荐使用HashMap，如果需要多线程高并发，推荐使用ConcurrentHashMap。</p>
</blockquote>
<h4 id="IdentityHashMap类"><a href="#IdentityHashMap类" class="headerlink" title="IdentityHashMap类"></a>IdentityHashMap类</h4><p>IdentityHashMap是比较小众的Map实现了。</p>
<blockquote>
<p>这个类不是一个通用的Map实现！虽然这个类实现了Map接口，但它故意违反了Map的约定，该约定要求在比较对象时使用equals方法，此类仅适用于需要引用相关等语句的极少数情况。</p>
</blockquote>
<blockquote>
<p>同HashMap，IdentityHashMap也是无序的，并且该类不是线程安全的，如果要使之线程安全，可以调用Collections.synchronizedMap(new IdentityHashMap(…))方法来实现。</p>
</blockquote>
<blockquote>
<p>支持fail-fast机制</p>
</blockquote>
<h4 id="WeakHashMap类"><a href="#WeakHashMap类" class="headerlink" title="WeakHashMap类"></a>WeakHashMap类</h4><p>WeakHashMap类基于哈希表的Map基础实现，带有弱键。WeakHashMap中的entry当不再使用时还会自动移除。更准确的说，给定key的映射的存在将不会阻止key被垃圾收集器丢弃。</p>
<blockquote>
<p>基于map接口，是一种弱键相连，WeakHashMap里面的键会自动回收</p>
</blockquote>
<blockquote>
<p>支持null值和null键。</p>
</blockquote>
<blockquote>
<p>fast-fail机制</p>
</blockquote>
<blockquote>
<p>不允许重复</p>
</blockquote>
<blockquote>
<p>WeakHashMap经常用作缓存</p>
</blockquote>
<h4 id="Collection类"><a href="#Collection类" class="headerlink" title="Collection类"></a>Collection类</h4><p>Collections不属于Java框架继承树上的内容，它属于单独的分支，Collections是一个包装类，它的作用就是为集合框架提供某些功能实现，此类只包括静态方法操作或者返回collections。</p>
<h4 id="同步包装"><a href="#同步包装" class="headerlink" title="同步包装"></a>同步包装</h4><p>同步包装器将自动同步（线程安全性）添加到任意集合。六个核心集合接口（Collection,Set,List,Map,SortedSet和SortedMap）中的每一个都有一个静态工厂方法。</p>
<p><code>public static Collection synchronizedCollection(Collection C);</code></p>
<p><code>public static Set synchronizedSet(Set s);</code></p>
<p><code>public static List synchronizedList(List list);</code></p>
<p><code>public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);</code></p>
<p><code>public static StortedSet synchronizedSortedSet(SortedSet s);</code></p>
<p><code>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m);</code></p>
<h4 id="不可修改的包装"><a href="#不可修改的包装" class="headerlink" title="不可修改的包装"></a>不可修改的包装</h4><p>不可修改的包装器通过拦截修改集合的操作并抛出UnsupportedOperationException，主要用在下面两个情景：</p>
<blockquote>
<p>构建集合后使其不可变。再在这种情况下，最好不要去获取返回的collection的引用，这样有利于保证不变性</p>
</blockquote>
<blockquote>
<p>允许某些客户端以只读方式访问你的数据结构。你保留的对返回的collection的引用，这样有利于保证不变性</p>
</blockquote>
<blockquote>
<p>允许某些客户端以只读方式访问你的数据结构。你保留对返回的collection的引用，但分发对包装器的引用。通过这种方式，客户可以查看但不能修改，同时保持完全访问权限。</p>
</blockquote>
<p>这些方法是：</p>
<p><code>public static Collection unmodifiableCollection(Collection&lt;? extends T&gt; c);</code></p>
<p><code>puistblic static Set undifiableSet(Set&lt;? extends T&gt; s);</code></p>
<p><code>public static List unmodifiableList(List&lt;? extends T&gt; list);</code></p>
<p><code>public static &lt;K,V&gt; Map&lt;K,V&gt;unmodifiableMap(Map&lt;? extends K,? extends V&gt; m);</code></p>
<p><code>public static SortedSet unmodifibleSortedSet(SortedSet&lt;? extends T&gt; s);</code></p>
<p><code>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; unmodifiableSortedMap(SortedMap&lt;K, ?extends V&gt; m);</code></p>
<h4 id="线程安全的Collections"><a href="#线程安全的Collections" class="headerlink" title="线程安全的Collections"></a>线程安全的Collections</h4><p>Java1.5并发包（java.util.concurrent)提供了线程安全的collections允许遍历的时候进行修改，通过设计iterator为fail-fast并抛出来ConsurrentModification。一些实现类是CopyOnWriteArrayList,ConcurrentHashMap,CopyOnWriteArraySet</p>
<h5 id="Collection算法"><a href="#Collection算法" class="headerlink" title="Collection算法"></a>Collection算法</h5><p>此类包含用于集合框架算法的方法，例如二进制搜索，排序，重排，反向等。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/11/03/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
                Untitled
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-11-03</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="==HashMap源码分析=="></a>==HashMap<strong>源码分析</strong>==</h1><h2 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h2><p>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体 </p>
<p>![](# images</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>{<strong>以下是 Gitee 平台说明，您可以替换此简介</strong><br>Gitee 是 OSCHINA 推出的基于 Git 的代码托管平台（同时支持 SVN）。专为开发者提供稳定、高效、安全的云端软件开发协作平台<br>无论是个人、团队、或是企业，都能够用 Gitee 实现代码托管、项目管理、协作开发。企业项目请看 <a target="_blank" rel="noopener" href="https://gitee.com/enterprises">https://gitee.com/enterprises</a>}</p>
<h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h4><p>软件架构说明</p>
<h4 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol>
<li> xxxx</li>
<li> xxxx</li>
<li> xxxx</li>
</ol>
<h4 id="参与贡献"><a href="#参与贡献" class="headerlink" title="参与贡献"></a>参与贡献</h4><ol>
<li> Fork 本仓库</li>
<li> 新建 Feat_xxx 分支</li>
<li> 提交代码</li>
<li> 新建 Pull Request</li>
</ol>
<h4 id="特技"><a href="#特技" class="headerlink" title="特技"></a>特技</h4><ol>
<li> 使用 Readme_XXX.md 来支持不同的语言，例如 Readme_en.md, Readme_zh.md</li>
<li> Gitee 官方博客 <a target="_blank" rel="noopener" href="https://blog.gitee.com/">blog.gitee.com</a></li>
<li> 你可以 <a target="_blank" rel="noopener" href="https://gitee.com/explore">https://gitee.com/explore</a> 这个地址来了解 Gitee 上的优秀开源项目</li>
<li> <a target="_blank" rel="noopener" href="https://gitee.com/gvp">GVP</a> 全称是 Gitee 最有价值开源项目，是综合评定出的优秀开源项目</li>
<li> Gitee 官方提供的使用手册 <a target="_blank" rel="noopener" href="https://gitee.com/help">https://gitee.com/help</a></li>
<li> Gitee 封面人物是一档用来展示 Gitee 会员风采的栏目 <a target="_blank" rel="noopener" href="https://gitee.com/gitee-stars/">https://gitee.com/gitee-stars/</a>)</li>
</ol>
<p>首先介绍一下Map。<img src="https://img-blog.csdnimg.cn/20190326222210343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0h1YW5neHVfTUlLVQ==,size_16,color_FFFFFF,t_70" alt="img">在数组中我们是通过数组下标来对其内容索引的，而在Map中我们通过<u><strong>对象</strong></u>来对==对象==进行索引，用来索引的<u><strong>对象</strong></u>叫做key，其对应的==对象==叫做value。</p>
<p>HashMap和TreeMap的区别。HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</p>
<p>在HashMap中通过get()来获取value，通过put()来插入value，ContainsKey()则用来检验对象是否已经存在。可以看出，和ArrayList的操作相比，HashMap除了通过key索引其内容之外，别的方面差异并不大。</p>
<p>HashMap是基于HashCode的，在所有对象的超类Object中有一个HashCode()方法，但是它和equals方法一样，并不能适用于所有的情况。</p>
<h5 id="上图中-A0-A5-为数组-其源码对应为"><a href="#上图中-A0-A5-为数组-其源码对应为" class="headerlink" title="上图中**==A0~A5==**为数组,其源码对应为"></a>上图中**==A0~A5==**为数组,其源码对应为</h5><p>` <strong>==transient Node&lt;K,V&gt;[] table;==</strong></p>
<pre><code>/**
 * Holds cached entrySet(). Note that AbstractMap fields are used
 * for keySet() and values().
 */`</code></pre>
<blockquote>
<p>HashMap里有一个名为tabled的数组.通过hash值的运算可以算出一个数组的下标，决定元素存储在数组的什么位置。这样下次查找的时候可以直接通过同样的方式，直接找到元素，而不用遍历数组。</p>
</blockquote>
<blockquote>
<p>计算方式：（数组长度 - 1）&amp;hash</p>
<p>数组长度是二的二次方，2^2^ 二进制是100，</p>
<p>​                                             2^3^ 二进制是1000，</p>
<p>​                                              2^4^ 是1000.</p>
<p>按照这个规律，长度 - 1，刚好是011，0111，01111. 将它作为掩码，来计算数组下标。</p>
</blockquote>
<blockquote>
<p>那么就用掩码和hash做与运算：</p>
<p>011&amp;101010100101001001101=01 下标=1， 数组长度=4</p>
<p>0111&amp;101010100101001001101=101 下标=5，数组长度=8</p>
<p>01111&amp;101010100101001001101=1101 下标=13，数组长度=16</p>
<p>可以发现，通过  掩码&amp;hash， 得出的数组下标不会越界。而数组的总长度总是2^n^ </p>
</blockquote>
<blockquote>
<p>上loat述计算中，hash值的高位，没有参与数组下标计算，而是被掩码掩盖掉了。假如有一类hash，特点是低位都为0，高位才发生变化。</p>
<p>例如 Float类：</p>
<p>System.out.println(Integer.toBinaryString(new Float(1).hashCode()));</p>
<p>System.out.println(Integer.toBinaryString(new Float(2).hashCode()));</p>
<p>System.out.println(Integer.toBinaryString(new Float(3).hashCode()));</p>
<p>System.out.println(Integer.toBinaryString(new Float(4).hashCode()));</p>
<p>System.out.println(Integer.toBinaryString(new Float(5).hashCode()));</p>
<p>System.out.println(Integer.toBinaryString(new Float(6).hashCode()));</p>
<p>输出结果：</p>
<p>111111100000000000000000000000</p>
<p>1000000000000000000000000000000</p>
<p>1000000010000000000000000000000</p>
<p>1000000100000000000000000000000</p>
<p>1000000101000000000000000000000</p>
<p>1000000110000000000000000000000</p>
<p>可以看到地位全部是0，那么直接拿来用的话，就会把发现算出来的数组下标全部是0，这样就全部冲突了。因此，为了避免这种特殊的情况，就需要高位也参与运算，这就是需要重新计算hash值的原因。</p>
</blockquote>
<h5 id="JDK1-8中红黑树的hash计算源码"><a href="#JDK1-8中红黑树的hash计算源码" class="headerlink" title="JDK1.8中红黑树的hash计算源码"></a>JDK1.8中红黑树的hash计算源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Computes key.hashCode() and spreads (XORs) higher bits of hash to lower.</span><br><span class="line">* * 换算下 key.hashCode() 的值，通过异或运算（XORs) 使高位扩散到低位。 </span><br><span class="line">* Because the table uses power-of-two masking, sets of hashes that vary</span><br><span class="line">only in bits above the current mask will always collide.</span><br><span class="line">* * 由于存储元素的table数组，采用的是 2 的次方的长度，并且以此作为下标取值掩码。</span><br><span class="line">那么对于，只有高于当前掩码长度的位会变化的 hash 来说，计算出来数组下标就会全部冲突</span><br><span class="line">* (Among known examples are sets of Float keys </span><br><span class="line">* holding consecutive whole numbers in small tables.)</span><br><span class="line">* * 其中一种已知的一种情况是 Float 作为 key，并且按照自然数顺序递增的</span><br><span class="line">存入一个小尺寸的table数组中</span><br><span class="line">* * So we apply a transform that spreads the impact of higher bits downward. </span><br><span class="line">* * 因此我们利用一种转换，来把高位的变化性扩散的低位去。</span><br><span class="line">* * There is a tradeoff between speed, utility, and quality of bit-spreading.</span><br><span class="line">* * 这是基于速度，效用和位扩散品质的一种权衡方案。</span><br><span class="line">* * Because many common sets of hashes are already reasonably distributed </span><br><span class="line">(so don&#39;t benefit from spreading), and because we use trees to handle large</span><br><span class="line">sets ofcollisions in bins, we just XOR some shifted bits in the cheapest</span><br><span class="line">possible way to reduce systematic lossage, as well as to incorporate impact</span><br><span class="line">of the highest bits that would otherwise never be used in index calculations</span><br><span class="line">because of table bounds.</span><br><span class="line">* * 因为许多常见的 hash 值都是适度分散的（因此位扩散的收益不大），又因为 </span><br><span class="line">* 我们使用树，来管控大数量的冲突元素。使用XOR异或运算来移位，可以尽可能低成本地 </span><br><span class="line">* 减少系统性损耗，也将原本不参与数组下标计算的高位的也给包含进来了。</span><br><span class="line">* *下面是将低16位和高16位做个异或运算，高16位保持不变</span><br><span class="line">* *static final int hash(Object key) </span><br><span class="line">* &#123; int h;</span><br><span class="line">* return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="HashCode扰动计算"><a href="#HashCode扰动计算" class="headerlink" title="HashCode扰动计算"></a>HashCode扰动计算</h5><p><img src="HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20201031171000257.png" alt="image-20201031171000257"></p>
<blockquote>
<p>这段代码是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单点说，就是为了把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终的结果产生影响。</p>
</blockquote>
<h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><p>HashMap的实例有两个参数影响其性能：初始容量和加载因子。容量是<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=4761024&ss_c=ssc.citiao.link">哈希表</a>中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行rehash操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。在<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=1544053&ss_c=ssc.citiao.link">Java编程语言</a>中，加载因子默认值为0.75，默认哈希表元为101[<a target="_blank" rel="noopener" href="https://baike.sogou.com/v8338448.htm?fromTitle=Hashmap#quote1">1]</a>。</p>
<h3 id="初始容量大小默认值为16"><a href="#初始容量大小默认值为16" class="headerlink" title="初始容量大小默认值为16"></a>初始容量大小默认值为16</h3><p><code> /*      * The default initial capacity - MUST be a power of two.           */         ==static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16==</code></p>
<blockquote>
<p>为了减小冲突的概率，当HashMap的数组长度到了一个临界值就会触发扩容，把所有元素rehash再放到扩容后的容器中，这是一个非常耗时的操作。</p>
</blockquote>
<blockquote>
<p>而这个临界值由<strong>加载因子</strong>和当前容器的容量大小来确定：DEFAULT_INITIAL_CAPACITY*DEFAULT_LOCAL_FACTOR,即默认情况下是16 * 0.75=12时，就会触发扩容操作。所以使用hash容器时尽量预估自己的数据来设置初始值。</p>
</blockquote>
<h3 id="加载因子默认0-75"><a href="#加载因子默认0-75" class="headerlink" title="加载因子默认0.75"></a>加载因子默认0.75</h3><p>`<strong>==static final float DEFAULT_LOAD_FACTOR = 0.75f;==</strong></p>
<pre><code>/**
 * The bin count threshold for using a tree rather than list for a
 * bin.  Bins are converted to trees when adding an element to a
 * bin with at least this many nodes. The value must be greater
 * than 2 and should be at least 8 to mesh with assumptions in
 * tree removal about conversion back to plain bins upon
 * shrinkage.
 */`</code></pre>
<blockquote>
<p>为容器使用树而不是列表时的容器计数阈值。<br>当向至少有这么多节点的bin中添加一个元素时，bin被转换为树。<br>该值必须大于2，并且至少应该是8，以符合在树移除时关于在收缩时转换回普通箱的假设。</p>
</blockquote>
<h5 id="源码中对0-75的解释"><a href="#源码中对0-75的解释" class="headerlink" title="源码中对0.75的解释"></a>源码中对0.75的解释</h5><p><img src="HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20201031183831717.png" alt="image-20201031183831717"></p>
<blockquote>
<p>wiki链接中的关键字：Poisssion_distribution==<strong>【泊松分布】</strong>==</p>
<p>再理想条件下，使用随机哈希码，节点出现的频率在hash桶中遵循泊松分布，同时给给出了桶中元素个数和概率的对照表。</p>
<p>从上面的表中可以看到当桶中元素达到8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过8个是几乎不可能的。</p>
</blockquote>
<h3 id="HashMap数组容量初始值不宜设置太高的原因"><a href="#HashMap数组容量初始值不宜设置太高的原因" class="headerlink" title="HashMap数组容量初始值不宜设置太高的原因"></a>HashMap数组容量初始值不宜设置太高的原因</h3><p>`<p>This implementation provides constant-time performance for the basic</p>
<ul>
<li>operations (<tt>get</tt> and <tt>put</tt>), assuming the hash function</li>
<li>disperses the elements properly among the buckets.  Iteration over</li>
<li>collection views requires time proportional to the “capacity” of the</li>
<li><tt>HashMap</tt> instance (the number of buckets) plus its size (the number</li>
<li>of key-value mappings).  Thus, it’s very important not to set the initial</li>
<li>capacity too high (or the load factor too low) if iteration performance is</li>
<li>important.`</li>
</ul>
<blockquote>
<p>HashMap 的实例有两个参数影响其性能：初始容量和加载因子。基于<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=4761024&ss_c=ssc.citiao.link">哈希表</a>的Map接口的实现。此实现提供所有可选的映射操作，并允许使用<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=46383579&ss_c=ssc.citiao.link">null值</a>和null键。（除了非同步和允许使用null之外，HashMap类与<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=403515&ss_c=ssc.citiao.link">Hashtable</a>大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。此实现假定<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=177729&ss_c=ssc.citiao.link">哈希函数</a>将元素适当地分布在各桶之间，可为基本操作（get和put）提供稳定的性能。迭代collection视图所需的时间与HashMap实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。</p>
</blockquote>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>当我们在使用迭代器的时候我们有两种方式，一个是通过keyset一个是entryset，通过第一中方式我们只能够通过getKey（）来获取key值，但是如果用entryset的话我们既可以获得key值又可以获得value值，分别通过getKey（）和getValue（)来获得。</p>
<ol>
<li><code>第一种:</code></li>
<li>　　<code>Map map = new HashMap();</code></li>
<li>　　<code>Iterator iter = map.entrySet().iterator();</code></li>
<li>　　<code>while (iter.hasNext()) &#123;</code></li>
<li>　　<code>Map.Entry entry = (Map.Entry) iter.next();</code></li>
<li>　　<code>Object key = entry.getKey();</code></li>
<li>　　<code>Object val = entry.getValue();</code></li>
<li>　　<code>&#125;</code></li>
<li>　　<code>效率高,以后一定要使用此种方式！</code></li>
<li><code>第二种:</code></li>
<li>　　<code>Map map = new HashMap();</code></li>
<li>　　<code>Iterator iter = map.keySet().iterator();</code></li>
<li>　　<code>while (iter.hasNext()) &#123;</code></li>
<li>　　<code>Object key = iter.next();</code></li>
<li>　　<code>Object val = map.get(key);</code></li>
<li>　　<code>&#125;</code></li>
<li>　　<code>效率低,以后尽量少使用！</code></li>
</ol>
<blockquote>
<p>由所有此类的“collection视图方法”所返回的<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8083528&ss_c=ssc.citiao.link">迭代器</a>都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove方法，而不冒在将来不确定的时间发生任意不确定行为的风险。</p>
<p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<p>遍历Hash中的元素</p>
<p>在Hash中可以直接使用一下方法遍历(所有键)KeySet</p>
<p>然后通过键可以找出需要的值</p>
<p><code>HashMap mp=new HashMap();</code></p>
<p><code>for(String i:mp.keySet())</code></p>
<p><code>&#123;</code></p>
<p><code>//String是mp中的键的对应类型;i是对应的KeySet中的每一个键值System.out.println(mp.get(i));</code></p>
<p><code>&#125;</code></p>
</blockquote>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="为什么要重写hashcode和equals方法"><a href="#为什么要重写hashcode和equals方法" class="headerlink" title="==为什么要重写hashcode和equals方法=="></a>==<u>为什么要重写hashcode和equals方法</u>==</h3><h6 id="首先复习一下Hash算法"><a href="#首先复习一下Hash算法" class="headerlink" title="首先复习一下Hash算法"></a>首先复习一下Hash算法</h6><p>数据结构知识点：在一个长度为n（假设是1000）的线性表（假设是ArrayyList）里，存放着无序数字；如果我们要找一个指定的数字，就不得不通过从头到尾依次遍历来查找。</p>
<p>Hash表：（特指数据结构中的概念，和Java无关）。它的平均查找次数接近于1，代价相当小，关键是在Hash表里，存放在其中的数据和它的存储位置是用Hash函数关联的。</p>
<p>我们假设一个Hash函数是x*x%5（实际不会用这么简单的Hash函数，为方便说明而举例）。Hash表是一个长度为11的线性表，如果把6用Hash函数计算一下，结果是1，所以我们就把6放入到索引号是1这个位置。同样，放数字7，经过Hsh计算，结果为4 ，它就会被放入到索引为4的这个位置。</p>
<p><img src="HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/mmexport1604198358195.jpg" alt="mmexport1604198358195"></p>
<p>这样做的好处很明显，例如我们要找6这个元素，我们可以先通过Hash函数计算6的索引位置，然后直接从1号索引里找到它了。不过我们会遇到hash冲突这个问题。例如经过7和8会有相同的Hash值，对此Java的HashMap对象采用的是“<strong>链地址法</strong>”的解决方案。效果如下：</p>
<p><img src="HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/mmexport1604199594355.jpg" alt="mmexport1604199594355"></p>
<p>具体做法是，为所有的Hash值是i的对象建立一个同义词链表。假设我们在放入8的时候，发现4号位置已经被占用，那么就会新建一个链表节点放入8.同样，如果我们查找8，那么发现4号索引里不是8，那么会沿着链表依次查找。</p>
<p>虽然我们还是无法彻底避免Hash值冲突的问题，但是Hash函数设计合理，仍能保证同义词链表的长度被控制在一个合理的范围里。</p>
<h6 id="重写equals和hashCode方法"><a href="#重写equals和hashCode方法" class="headerlink" title="重写equals和hashCode方法"></a>重写equals和hashCode方法</h6><p>当我们用HashMap存入自定义的类时，如果不重写这个自定义类的equals和hashCode方法，得到的结果会和我们预期的不一样。我们来看WithoutHashCode.java这个例子。</p>
<p>在其中的第2行到第18行，我们定义了一个Key类；在其中的第3行定义了唯一的一个属性id。当前我们先注释掉第9行的equals方法的第16行的hashCode方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="keyword">this</span>.id=id;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(o==<span class="keyword">null</span>||!(o <span class="keyword">instanceof</span> Key))</span><br><span class="line">		&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;<span class="keyword">return</span> <span class="keyword">this</span>.getId().equals(((Key)o).getId());&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id.hashCode();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithputHashCode</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Key k1=<span class="keyword">new</span> Key(<span class="number">1</span>);</span><br><span class="line">		Key k2=<span class="keyword">new</span> Key(<span class="number">1</span>);</span><br><span class="line">		HashMap&lt;Key,String&gt;hm=<span class="keyword">new</span> HashMap&lt;Key,String&gt;();</span><br><span class="line">		hm.put(k1,<span class="string">&quot;Key with id is 1&quot;</span>);</span><br><span class="line">		System.out.println(hm.get(k2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在main函数里的第20行和第21行，我们定义了两个Key对象，它们的id都是1，就好比它们是把相同的都能打开同一扇门的钥匙。</p>
<p>在第22行里，我们通过泛型创建了一个HashMap对象。它的键部分可以存放Key类型的对象，值部分可以存储String类型的对象。</p>
<p>在第23行里，通过put方法把k1和一串字符串放入到hm里；而在第24行，我们想用k2去从HashMap里得到值；这就好比我们想用k1这把钥匙来锁门，用k2来开门。这是符合逻辑的，但从结果来看，24行的返回值结果不是我们想象的那个字符串，而是null。</p>
<p>原因有两个：<strong>一是没有重写hashCode方法，二是没有重写equals方法。</strong></p>
<p>当我们在HashMap里放k1时，首先会调用Key这个类的hashCode方法来计算它的hash值，随后把k1放入hash值所指引的内存位置。</p>
<p>关键是我们没有在Key里定义hashCode方法。这里调用的仍是Object类的hashCode方法（所有类都是Object类的子类），而Object类的hashCode方法返回的hash值其实是k1对象的内存地址（假设是1000）。</p>
<p><img src="HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/mmexport1604204004534.jpg" alt="mmexport1604204004534"></p>
<p>如果随后调用hm.get(k1)，那么我们会再次调用hashCode方法（还是返回k1的地址1000），随后根据得到的hash值，很快的找到k1.</p>
<p>但我们这里的代码时hm.get(k2),当我们调用Object类的hashCode方法（因为Key里没有定义）计算k2的hash值时，其实得到的是k2的内存地址（假设是2000）。由于k1和k2是两个不同的对象，所以它们的内存地址一定不会相同，也就是说它们的hash值一定不同，这就是我们无法用k2的hash值去拿k1的原因。</p>
<p>当我们把第16行和第15行的hashCode方法的注释去掉以后，会发现它返回id属性的hashCode值，这里k1和k2的id都是1，所以它们的hash值是相等的。</p>
<p>我们再来更正一下存k1和取k2的动作。存k1时，是根据它id的hash值，假设这里是100，把k1对象放入到对应的位置。而取k2时，是先计算它的hash值（由于k2的id也是1，这个值也是100），随后到这个位置去找。</p>
<p>但结果会出乎我们意料：明明100号位置已经有k1，但第24行的输出结果依然是null。其原因是没有重写Key对象的equals方法。</p>
<p>HashMap是用<strong>链地址法</strong>来处理冲突，也就是说，在100号位置上，有可能存在着多个用链表形式存储的对象。它们通过hashCode方法返回的hash值都是100.</p>
<p><img src="HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/mmexport1604205560994-1604212341100.jpg" alt="mmexport1604205560994"></p>
<p>当我们通过k2的hashCode到100号位置查找时，确实会得到k1.但k1有可能仅仅是和k2具有相同的hash值，但未必相等（两把钥匙未必能开一把锁)，这个时候，就需要用key对象的equals方法来判断两者是否相等了。</p>
<p>由于我们在Key对象里没有定义equals方法，系统就不得不调用Object类的equals方法。由于Object的固有方法是根据两个对象的内存地址来判断，所以k1和k2一定不会相等，这就是为什么依然在24行通过hm.get(k2)依然得到null的原因。</p>
<p>为了解决这个问题，我们需要打开第9行到第14行equals方法的注释。在这个方法里，只要两个对象都是Key类型，而且它们的id相等，它们就相等。</p>
<blockquote>
<p><strong>最后再强调一下</strong>：如果要在HashMap的“键”部分存放自定义的对象，一定要在这个对象里用自己的equals和hashCode方法来覆盖Object里的同名方法。</p>
</blockquote>
<p>链表部分 参考 知乎 <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/chou-da-ma-de-tu-zi">长者见闻</a>  文章<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/62923854">https://www.zhihu.com/question/62923854</a></p>
<p>迭代部分 参考 CSDN <a target="_blank" rel="noopener" href="https://me.csdn.net/Huangxu_MIKU">Skeram_Huang</a> 文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/Huangxu_MIKU/article/details/88832067">https://blog.csdn.net/Huangxu_MIKU/article/details/88832067</a> </p>
<p>面试题  参考  微信公众号 CodeSheep</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/10/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">
                我的第一篇博客文章
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-10-30</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>代码块</p>
<blockquote>
</blockquote>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="http://www.codesheep.cn/">www.codesheep.cn</a></p>
<p>–insert–</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/10/30/hello-world/">
                Hello World
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-10-30</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

        </div>
    

</div>
            
        </section>
    </div>
</div>






</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a target="_blank" rel="noopener" href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/11/15/Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B4%E5%90%88/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/11/09/Java%E5%9F%BA%E7%A1%80/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/11/06/%E9%9B%86%E5%90%88/">Untitled</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/11/03/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Untitled</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://telegram.org/">
                            <span class="footer-icon-container">
                                <i class="fa fa-telegram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>